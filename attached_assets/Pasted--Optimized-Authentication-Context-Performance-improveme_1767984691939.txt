/**
 * Optimized Authentication Context
 * 
 * Performance improvements:
 * 1. Cache auth state in sessionStorage for instant load
 * 2. Prefetch CSRF token in parallel
 * 3. Combine /me and /csrf into single call when possible
 * 4. Non-blocking session refresh
 */

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
  type ReactNode,
} from 'react';
import { useLocation } from 'wouter';
import { useQueryClient } from '@tanstack/react-query';

// ============================================================================
// Types
// ============================================================================

export type AuthProvider = 'replit' | 'email' | 'both';

export interface User {
  id: number;
  email: string;
  firstName: string | null;
  lastName: string | null;
  avatarUrl: string | null;
  role: string;
  authProvider: AuthProvider;
  emailVerified: boolean;
  replitId: string | null;
}

export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

export interface AuthContextValue extends AuthState {
  login: (credentials: { email: string; password: string }) => Promise<{ success: boolean; error?: string }>;
  loginWithReplit: () => Promise<{ success: boolean }>;
  register: (credentials: { email: string; password: string; firstName?: string; lastName?: string }) => Promise<{ success: boolean; error?: string }>;
  logout: () => Promise<void>;
  logoutAll: () => Promise<void>;
  refreshUser: () => Promise<void>;
  changePassword: (currentPassword: string, newPassword: string) => Promise<{ success: boolean; error?: string }>;
  requestPasswordReset: (email: string) => Promise<{ success: boolean; error?: string }>;
  resetPassword: (token: string, password: string) => Promise<{ success: boolean; error?: string }>;
  resendVerificationEmail: () => Promise<{ success: boolean; error?: string }>;
  clearError: () => void;
  hasPassword: boolean;
  canAddPassword: boolean;
}

// ============================================================================
// Constants
// ============================================================================

const AUTH_CACHE_KEY = 'reawakened_auth_cache';
const CSRF_CACHE_KEY = 'reawakened_csrf';
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// ============================================================================
// Cache Utilities
// ============================================================================

interface CachedAuth {
  user: User;
  timestamp: number;
}

function getCachedAuth(): User | null {
  try {
    const cached = sessionStorage.getItem(AUTH_CACHE_KEY);
    if (!cached) return null;
    
    const { user, timestamp }: CachedAuth = JSON.parse(cached);
    
    // Check if cache is still valid
    if (Date.now() - timestamp > CACHE_TTL) {
      sessionStorage.removeItem(AUTH_CACHE_KEY);
      return null;
    }
    
    return user;
  } catch {
    return null;
  }
}

function setCachedAuth(user: User | null): void {
  if (user) {
    sessionStorage.setItem(AUTH_CACHE_KEY, JSON.stringify({
      user,
      timestamp: Date.now(),
    }));
  } else {
    sessionStorage.removeItem(AUTH_CACHE_KEY);
  }
}

// ============================================================================
// CSRF Token Management (Optimized)
// ============================================================================

let csrfToken: string | null = null;
let csrfPromise: Promise<string> | null = null;

async function fetchCsrfToken(): Promise<string> {
  // Return cached token if available
  if (csrfToken) return csrfToken;
  
  // Check sessionStorage
  const cached = sessionStorage.getItem(CSRF_CACHE_KEY);
  if (cached) {
    csrfToken = cached;
    return csrfToken;
  }
  
  // Deduplicate concurrent requests
  if (csrfPromise) return csrfPromise;
  
  csrfPromise = fetch('/api/auth/csrf', { credentials: 'include' })
    .then(res => {
      if (!res.ok) throw new Error('Failed to fetch CSRF token');
      return res.json();
    })
    .then(data => {
      csrfToken = data.csrfToken;
      sessionStorage.setItem(CSRF_CACHE_KEY, csrfToken!);
      return csrfToken!;
    })
    .finally(() => {
      csrfPromise = null;
    });
  
  return csrfPromise;
}

function clearCsrfToken(): void {
  csrfToken = null;
  sessionStorage.removeItem(CSRF_CACHE_KEY);
}

// ============================================================================
// API Helper (Optimized)
// ============================================================================

async function authFetch<T>(
  url: string,
  options: RequestInit = {}
): Promise<{ data?: T; error?: string; status: number }> {
  try {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...(options.headers as Record<string, string>),
    };
    
    // Only fetch CSRF for mutation requests
    if (options.method && options.method !== 'GET') {
      const token = await fetchCsrfToken();
      headers['X-CSRF-Token'] = token;
    }
    
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 10000); // 10s timeout
    
    const response = await fetch(url, {
      ...options,
      headers,
      credentials: 'include',
      signal: controller.signal,
    });
    
    clearTimeout(timeout);
    
    const data = await response.json().catch(() => null);
    
    if (!response.ok) {
      return { error: data?.error || 'An error occurred', status: response.status };
    }
    
    // Update CSRF token if provided
    if (data?.csrfToken) {
      csrfToken = data.csrfToken;
      sessionStorage.setItem(CSRF_CACHE_KEY, csrfToken);
    }
    
    return { data, status: response.status };
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      return { error: 'Request timed out', status: 0 };
    }
    return { error: error instanceof Error ? error.message : 'Network error', status: 0 };
  }
}

// ============================================================================
// Context
// ============================================================================

const AuthContext = createContext<AuthContextValue | null>(null);

// ============================================================================
// Provider (Optimized)
// ============================================================================

export function AuthProvider({ children }: { children: ReactNode }) {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  const loadingRef = useRef(false);
  
  // Initialize with cached state for instant render
  const [state, setState] = useState<AuthState>(() => {
    const cachedUser = getCachedAuth();
    return {
      user: cachedUser,
      isAuthenticated: !!cachedUser,
      isLoading: true, // Still verify with server
      error: null,
    };
  });

  // Prefetch CSRF token immediately
  useEffect(() => {
    fetchCsrfToken().catch(() => {});
  }, []);

  // Verify auth state with server
  const loadUser = useCallback(async () => {
    // Prevent concurrent loads
    if (loadingRef.current) return;
    loadingRef.current = true;
    
    try {
      const { data, status } = await authFetch<{ user: User }>('/api/auth/me');
      
      if (data?.user) {
        setCachedAuth(data.user);
        setState({
          user: data.user,
          isAuthenticated: true,
          isLoading: false,
          error: null,
        });
      } else {
        setCachedAuth(null);
        setState({
          user: null,
          isAuthenticated: false,
          isLoading: false,
          error: status === 401 ? null : 'Failed to load user',
        });
      }
    } finally {
      loadingRef.current = false;
    }
  }, []);

  // Load user on mount
  useEffect(() => {
    loadUser();
  }, [loadUser]);

  const login = useCallback(async (credentials: { email: string; password: string }) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    const { data, error } = await authFetch<{ user: User }>('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    
    if (data?.user) {
      setCachedAuth(data.user);
      setState({
        user: data.user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
      queryClient.invalidateQueries();
      return { success: true };
    }
    
    setState(prev => ({ ...prev, isLoading: false, error: error || 'Login failed' }));
    return { success: false, error: error || 'Login failed' };
  }, [queryClient]);

  const loginWithReplit = useCallback(async () => {
    window.location.href = '/__repl/auth/login';
    return { success: true };
  }, []);

  const register = useCallback(async (credentials: { email: string; password: string; firstName?: string; lastName?: string }) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    const { data, error } = await authFetch<{ user: User }>('/api/auth/register', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    
    if (data?.user) {
      setCachedAuth(data.user);
      setState({
        user: data.user,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      });
      queryClient.invalidateQueries();
      return { success: true };
    }
    
    setState(prev => ({ ...prev, isLoading: false, error: error || 'Registration failed' }));
    return { success: false, error: error || 'Registration failed' };
  }, [queryClient]);

  const logout = useCallback(async () => {
    await authFetch('/api/auth/logout', { method: 'POST' });
    clearCsrfToken();
    setCachedAuth(null);
    setState({ user: null, isAuthenticated: false, isLoading: false, error: null });
    queryClient.clear();
    setLocation('/');
  }, [queryClient, setLocation]);

  const logoutAll = useCallback(async () => {
    await authFetch('/api/auth/logout-all', { method: 'POST' });
    clearCsrfToken();
    setCachedAuth(null);
    setState({ user: null, isAuthenticated: false, isLoading: false, error: null });
    queryClient.clear();
    setLocation('/');
  }, [queryClient, setLocation]);

  const refreshUser = useCallback(async () => {
    await loadUser();
  }, [loadUser]);

  const changePassword = useCallback(async (currentPassword: string, newPassword: string) => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/change-password', {
      method: 'POST',
      body: JSON.stringify({ currentPassword, newPassword }),
    });
    if (data) {
      await loadUser();
      return { success: true };
    }
    return { success: false, error: error || 'Failed to change password' };
  }, [loadUser]);

  const requestPasswordReset = useCallback(async (email: string) => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/forgot-password', {
      method: 'POST',
      body: JSON.stringify({ email }),
    });
    return data ? { success: true } : { success: false, error: error || 'Failed to send reset email' };
  }, []);

  const resetPassword = useCallback(async (token: string, password: string) => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/reset-password', {
      method: 'POST',
      body: JSON.stringify({ token, password }),
    });
    return data ? { success: true } : { success: false, error: error || 'Failed to reset password' };
  }, []);

  const resendVerificationEmail = useCallback(async () => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/resend-verification', { method: 'POST' });
    return data ? { success: true } : { success: false, error: error || 'Failed to send verification email' };
  }, []);

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);

  const hasPassword = state.user?.authProvider === 'email' || state.user?.authProvider === 'both';
  const canAddPassword = state.user?.authProvider === 'replit';

  const value = useMemo<AuthContextValue>(() => ({
    ...state,
    login,
    loginWithReplit,
    register,
    logout,
    logoutAll,
    refreshUser,
    changePassword,
    requestPasswordReset,
    resetPassword,
    resendVerificationEmail,
    clearError,
    hasPassword,
    canAddPassword,
  }), [state, login, loginWithReplit, register, logout, logoutAll, refreshUser,
      changePassword, requestPasswordReset, resetPassword, resendVerificationEmail,
      clearError, hasPassword, canAddPassword]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// ============================================================================
// Hooks
// ============================================================================

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within an AuthProvider');
  return context;
}

export function useRequireAuth(redirectTo: string = '/login') {
  const { isAuthenticated, isLoading } = useAuth();
  const [, setLocation] = useLocation();
  
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      const returnUrl = encodeURIComponent(window.location.pathname);
      setLocation(`${redirectTo}?redirect=${returnUrl}`);
    }
  }, [isAuthenticated, isLoading, redirectTo, setLocation]);
  
  return { isAuthenticated, isLoading };
}

export function useDisplayName(): string {
  const { user } = useAuth();
  if (!user) return '';
  if (user.firstName) return user.lastName ? `${user.firstName} ${user.lastName}` : user.firstName;
  return user.email.split('@')[0];
}