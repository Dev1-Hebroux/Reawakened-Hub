/**
 * Authentication Context
 * 
 * React context for managing dual authentication state.
 * Supports both Replit SSO and Email/Password authentication.
 * Uses wouter for routing.
 */

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
  type ReactNode,
} from 'react';
import { useLocation } from 'wouter';
import { useQueryClient } from '@tanstack/react-query';

// ============================================================================
// Types
// ============================================================================

export type AuthProvider = 'replit' | 'email' | 'both';

export interface User {
  id: number;
  email: string;
  firstName: string | null;
  lastName: string | null;
  avatarUrl: string | null;
  role: string;
  authProvider: AuthProvider;
  emailVerified: boolean;
  replitId: string | null;
}

export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  authMethod: 'session' | 'replit' | null;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterCredentials {
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
}

export interface AuthResult {
  success: boolean;
  error?: string;
}

export interface AuthContextValue extends AuthState {
  login: (credentials: LoginCredentials) => Promise<AuthResult>;
  loginWithReplit: () => Promise<AuthResult>;
  register: (credentials: RegisterCredentials) => Promise<AuthResult>;
  logout: () => Promise<void>;
  logoutAll: () => Promise<void>;
  refreshUser: () => Promise<void>;
  changePassword: (currentPassword: string, newPassword: string) => Promise<AuthResult>;
  requestPasswordReset: (email: string) => Promise<AuthResult>;
  resetPassword: (token: string, password: string) => Promise<AuthResult>;
  resendVerificationEmail: () => Promise<AuthResult>;
  clearError: () => void;
  hasPassword: boolean;
  canAddPassword: boolean;
}

// ============================================================================
// Context
// ============================================================================

const AuthContext = createContext<AuthContextValue | null>(null);

// CSRF Token Management
let csrfToken: string | null = null;

async function fetchCsrfToken(): Promise<string> {
  if (csrfToken) return csrfToken;
  const response = await fetch('/api/auth/csrf', { credentials: 'include' });
  if (response.ok) {
    const data = await response.json();
    csrfToken = data.csrfToken;
    return csrfToken;
  }
  throw new Error('Failed to fetch CSRF token');
}

function clearCsrfToken(): void {
  csrfToken = null;
}

// API Helper
async function authFetch<T>(
  url: string,
  options: RequestInit = {}
): Promise<{ data?: T; error?: string; status: number }> {
  try {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...(options.headers as Record<string, string>),
    };
    
    if (options.method && options.method !== 'GET') {
      const token = await fetchCsrfToken();
      headers['X-CSRF-Token'] = token;
    }
    
    const response = await fetch(url, { ...options, headers, credentials: 'include' });
    const data = await response.json().catch(() => null);
    
    if (!response.ok) {
      return { error: data?.error || 'An error occurred', status: response.status };
    }
    
    if (data?.csrfToken) csrfToken = data.csrfToken;
    return { data, status: response.status };
  } catch (error) {
    return { error: error instanceof Error ? error.message : 'Network error', status: 0 };
  }
}

// ============================================================================
// Provider
// ============================================================================

export function AuthProvider({ children }: { children: ReactNode }) {
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();
  
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
    error: null,
    authMethod: null,
  });

  const loadUser = useCallback(async () => {
    setState(prev => ({ ...prev, isLoading: true }));
    const { data, error, status } = await authFetch<{ user: User }>('/api/auth/me');
    
    if (data?.user) {
      setState({ user: data.user, isAuthenticated: true, isLoading: false, error: null, authMethod: 'session' });
    } else {
      setState({ user: null, isAuthenticated: false, isLoading: false, error: status === 401 ? null : error || null, authMethod: null });
    }
  }, []);

  useEffect(() => { loadUser(); }, [loadUser]);

  const login = useCallback(async (credentials: LoginCredentials): Promise<AuthResult> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    const { data, error } = await authFetch<{ user: User }>('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    
    if (data?.user) {
      setState({ user: data.user, isAuthenticated: true, isLoading: false, error: null, authMethod: 'session' });
      queryClient.invalidateQueries();
      return { success: true };
    }
    
    setState(prev => ({ ...prev, isLoading: false, error: error || 'Login failed' }));
    return { success: false, error: error || 'Login failed' };
  }, [queryClient]);

  const loginWithReplit = useCallback(async (): Promise<AuthResult> => {
    window.location.href = '/__repl/auth/login';
    return { success: true };
  }, []);

  const register = useCallback(async (credentials: RegisterCredentials): Promise<AuthResult> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    const { data, error } = await authFetch<{ user: User }>('/api/auth/register', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
    
    if (data?.user) {
      setState({ user: data.user, isAuthenticated: true, isLoading: false, error: null, authMethod: 'session' });
      queryClient.invalidateQueries();
      return { success: true };
    }
    
    setState(prev => ({ ...prev, isLoading: false, error: error || 'Registration failed' }));
    return { success: false, error: error || 'Registration failed' };
  }, [queryClient]);

  const logout = useCallback(async () => {
    await authFetch('/api/auth/logout', { method: 'POST' });
    clearCsrfToken();
    setState({ user: null, isAuthenticated: false, isLoading: false, error: null, authMethod: null });
    queryClient.clear();
    setLocation('/');
  }, [queryClient, setLocation]);

  const logoutAll = useCallback(async () => {
    await authFetch('/api/auth/logout-all', { method: 'POST' });
    clearCsrfToken();
    setState({ user: null, isAuthenticated: false, isLoading: false, error: null, authMethod: null });
    queryClient.clear();
    setLocation('/');
  }, [queryClient, setLocation]);

  const refreshUser = useCallback(async () => { await loadUser(); }, [loadUser]);

  const changePassword = useCallback(async (currentPassword: string, newPassword: string): Promise<AuthResult> => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/change-password', {
      method: 'POST',
      body: JSON.stringify({ currentPassword, newPassword }),
    });
    if (data) { await loadUser(); return { success: true }; }
    return { success: false, error: error || 'Failed to change password' };
  }, [loadUser]);

  const requestPasswordReset = useCallback(async (email: string): Promise<AuthResult> => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/forgot-password', {
      method: 'POST',
      body: JSON.stringify({ email }),
    });
    return data ? { success: true } : { success: false, error: error || 'Failed to send reset email' };
  }, []);

  const resetPassword = useCallback(async (token: string, password: string): Promise<AuthResult> => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/reset-password', {
      method: 'POST',
      body: JSON.stringify({ token, password }),
    });
    return data ? { success: true } : { success: false, error: error || 'Failed to reset password' };
  }, []);

  const resendVerificationEmail = useCallback(async (): Promise<AuthResult> => {
    const { data, error } = await authFetch<{ message: string }>('/api/auth/resend-verification', { method: 'POST' });
    return data ? { success: true } : { success: false, error: error || 'Failed to send verification email' };
  }, []);

  const clearError = useCallback(() => { setState(prev => ({ ...prev, error: null })); }, []);

  const hasPassword = state.user?.authProvider === 'email' || state.user?.authProvider === 'both';
  const canAddPassword = state.user?.authProvider === 'replit';

  const value = useMemo<AuthContextValue>(() => ({
    ...state, login, loginWithReplit, register, logout, logoutAll, refreshUser,
    changePassword, requestPasswordReset, resetPassword, resendVerificationEmail,
    clearError, hasPassword, canAddPassword,
  }), [state, login, loginWithReplit, register, logout, logoutAll, refreshUser,
      changePassword, requestPasswordReset, resetPassword, resendVerificationEmail,
      clearError, hasPassword, canAddPassword]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// ============================================================================
// Hooks
// ============================================================================

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within an AuthProvider');
  return context;
}

export function useRequireAuth(redirectTo: string = '/login') {
  const { isAuthenticated, isLoading } = useAuth();
  const [, setLocation] = useLocation();
  
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      const returnUrl = encodeURIComponent(window.location.pathname);
      setLocation(`${redirectTo}?redirect=${returnUrl}`);
    }
  }, [isAuthenticated, isLoading, redirectTo, setLocation]);
  
  return { isAuthenticated, isLoading };
}

export function useRequireRole(role: string, redirectTo: string = '/') {
  const { user, isAuthenticated, isLoading } = useAuth();
  const [, setLocation] = useLocation();
  const hasRole = user?.role === role || user?.role === 'admin';
  
  useEffect(() => {
    if (!isLoading && isAuthenticated && !hasRole) setLocation(redirectTo);
  }, [isAuthenticated, isLoading, hasRole, redirectTo, setLocation]);
  
  return { hasRole, isLoading };
}

export function useHasRole(role: string): boolean {
  const { user } = useAuth();
  if (!user) return false;
  return user.role === 'admin' || user.role === role;
}

export function useDisplayName(): string {
  const { user } = useAuth();
  if (!user) return '';
  if (user.firstName) return user.lastName ? `${user.firstName} ${user.lastName}` : user.firstName;
  return user.email.split('@')[0];
}