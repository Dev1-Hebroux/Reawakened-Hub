/**
 * Optimized Auth Middleware
 * 
 * Performance improvements:
 * 1. Single query for session + user validation
 * 2. Non-blocking session activity updates
 * 3. In-memory session cache (optional)
 * 4. Faster CSRF validation
 */

import { Request, Response, NextFunction } from 'express';
import { db } from '../db';
import { sql } from 'drizzle-orm';
import crypto from 'crypto';

// ============================================================================
// Configuration
// ============================================================================

const SESSION_COOKIE_NAME = 'reawakened_session';
const CSRF_COOKIE_NAME = 'reawakened_csrf';
const CSRF_HEADER_NAME = 'x-csrf-token';

const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax' as const,
  path: '/',
  maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
};

// ============================================================================
// Types
// ============================================================================

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: number;
        email: string;
        firstName: string | null;
        lastName: string | null;
        role: string;
        emailVerified: boolean;
        authProvider: string;
        replitId: string | null;
      };
      sessionToken?: string;
    }
  }
}

// ============================================================================
// Optional: In-Memory Session Cache
// ============================================================================

interface CachedSession {
  user: Express.Request['user'];
  expiresAt: number;
  cachedAt: number;
}

const sessionCache = new Map<string, CachedSession>();
const CACHE_TTL = 60 * 1000; // 1 minute cache

function getCachedSession(token: string): Express.Request['user'] | null {
  const cached = sessionCache.get(token);
  if (!cached) return null;
  
  // Check if cache is still valid
  if (Date.now() - cached.cachedAt > CACHE_TTL) {
    sessionCache.delete(token);
    return null;
  }
  
  // Check if session hasn't expired
  if (cached.expiresAt < Date.now()) {
    sessionCache.delete(token);
    return null;
  }
  
  return cached.user;
}

function setCachedSession(token: string, user: Express.Request['user'], expiresAt: Date): void {
  sessionCache.set(token, {
    user,
    expiresAt: expiresAt.getTime(),
    cachedAt: Date.now(),
  });
  
  // Cleanup old entries periodically
  if (sessionCache.size > 1000) {
    const now = Date.now();
    for (const [key, value] of sessionCache.entries()) {
      if (now - value.cachedAt > CACHE_TTL) {
        sessionCache.delete(key);
      }
    }
  }
}

function invalidateCachedSession(token: string): void {
  sessionCache.delete(token);
}

// ============================================================================
// Optimized Session Validation (Single Query)
// ============================================================================

async function validateSessionOptimized(token: string): Promise<{
  user: Express.Request['user'] | null;
  expiresAt: Date | null;
}> {
  // Check cache first
  const cached = getCachedSession(token);
  if (cached) {
    return { user: cached, expiresAt: null };
  }
  
  // Single query to get session + user
  const result = await db.execute(sql`
    SELECT 
      s.id as session_id,
      s.expires_at,
      u.id,
      u.email,
      u.first_name,
      u.last_name,
      u.role,
      u.email_verified_at IS NOT NULL as email_verified,
      u.auth_provider,
      u.replit_id
    FROM user_sessions s
    JOIN users u ON s.user_id = u.id
    WHERE s.token = ${token}
      AND s.expires_at > NOW()
      AND (u.is_disabled IS NULL OR u.is_disabled = false)
    LIMIT 1
  `);
  
  if (!result.rows || result.rows.length === 0) {
    return { user: null, expiresAt: null };
  }
  
  const row = result.rows[0] as any;
  
  const user: Express.Request['user'] = {
    id: row.id,
    email: row.email,
    firstName: row.first_name,
    lastName: row.last_name,
    role: row.role,
    emailVerified: row.email_verified,
    authProvider: row.auth_provider,
    replitId: row.replit_id,
  };
  
  const expiresAt = new Date(row.expires_at);
  
  // Cache the result
  setCachedSession(token, user, expiresAt);
  
  // Update last activity in background (non-blocking)
  updateSessionActivity(row.session_id).catch(() => {});
  
  return { user, expiresAt };
}

// Non-blocking activity update
async function updateSessionActivity(sessionId: number): Promise<void> {
  await db.execute(sql`
    UPDATE user_sessions 
    SET last_activity_at = NOW() 
    WHERE id = ${sessionId}
  `);
}

// ============================================================================
// Middleware Functions
// ============================================================================

/**
 * Load user from session (optimized)
 */
export async function loadUser(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const token = req.cookies?.[SESSION_COOKIE_NAME];
    
    if (!token) {
      return next();
    }
    
    const { user, expiresAt } = await validateSessionOptimized(token);
    
    if (user) {
      req.user = user;
      req.sessionToken = token;
      
      // Refresh session if approaching expiration (< 7 days)
      if (expiresAt && expiresAt.getTime() - Date.now() < 7 * 24 * 60 * 60 * 1000) {
        refreshSession(token, res).catch(() => {});
      }
    } else {
      // Invalid session, clear cookie
      res.clearCookie(SESSION_COOKIE_NAME, { path: '/' });
    }
    
    next();
  } catch (error) {
    // Don't fail the request on auth errors
    console.error('Error loading user session:', error);
    next();
  }
}

// Non-blocking session refresh
async function refreshSession(token: string, res: Response): Promise<void> {
  const newExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
  
  await db.execute(sql`
    UPDATE user_sessions 
    SET expires_at = ${newExpiresAt}
    WHERE token = ${token}
  `);
  
  // Update cookie expiration
  res.cookie(SESSION_COOKIE_NAME, token, COOKIE_OPTIONS);
  
  // Invalidate cache so next request gets fresh data
  invalidateCachedSession(token);
}

/**
 * Require authentication
 */
export function requireAuth(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.user) {
    res.status(401).json({ error: 'Authentication required', code: 'AUTH_REQUIRED' });
    return;
  }
  next();
}

/**
 * Require specific role
 */
export function requireRole(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({ error: 'Authentication required', code: 'AUTH_REQUIRED' });
      return;
    }
    
    if (!roles.includes(req.user.role) && req.user.role !== 'admin') {
      res.status(403).json({ error: 'Access denied', code: 'INSUFFICIENT_PERMISSIONS' });
      return;
    }
    
    next();
  };
}

export const requireAdmin = requireRole('admin');

// ============================================================================
// CSRF Protection (Optimized)
// ============================================================================

export function generateCsrfToken(res: Response): string {
  const token = crypto.randomBytes(32).toString('hex');
  
  res.cookie(CSRF_COOKIE_NAME, token, {
    ...COOKIE_OPTIONS,
    httpOnly: false, // Must be readable by JavaScript
  });
  
  return token;
}

// Pre-computed safe methods set for faster lookup
const SAFE_METHODS = new Set(['GET', 'HEAD', 'OPTIONS']);

export function csrfProtection(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Skip CSRF for safe methods
  if (SAFE_METHODS.has(req.method)) {
    return next();
  }
  
  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];
  const headerToken = req.headers[CSRF_HEADER_NAME] as string;
  
  if (!cookieToken || !headerToken) {
    res.status(403).json({ error: 'Missing CSRF token', code: 'CSRF_MISSING' });
    return;
  }
  
  // Fast length check before expensive comparison
  if (cookieToken.length !== headerToken.length) {
    res.status(403).json({ error: 'Invalid CSRF token', code: 'CSRF_INVALID' });
    return;
  }
  
  // Constant-time comparison
  try {
    const valid = crypto.timingSafeEqual(
      Buffer.from(cookieToken),
      Buffer.from(headerToken)
    );
    
    if (!valid) {
      res.status(403).json({ error: 'Invalid CSRF token', code: 'CSRF_INVALID' });
      return;
    }
  } catch {
    res.status(403).json({ error: 'Invalid CSRF token', code: 'CSRF_INVALID' });
    return;
  }
  
  next();
}

/**
 * Ensure CSRF token is set
 */
export function ensureCsrfToken(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.cookies?.[CSRF_COOKIE_NAME]) {
    generateCsrfToken(res);
  }
  next();
}

// ============================================================================
// Cookie Utilities
// ============================================================================

export function setSessionCookie(res: Response, token: string): void {
  res.cookie(SESSION_COOKIE_NAME, token, COOKIE_OPTIONS);
}

export function clearSessionCookie(res: Response): void {
  res.clearCookie(SESSION_COOKIE_NAME, { path: '/' });
}

export function getSessionToken(req: Request): string | null {
  return req.cookies?.[SESSION_COOKIE_NAME] || null;
}

// ============================================================================
// Rate Limiting (Optimized)
// ============================================================================

interface RateLimitRecord {
  count: number;
  resetAt: number;
}

const rateLimitStore = new Map<string, RateLimitRecord>();

// Cleanup every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, record] of rateLimitStore.entries()) {
    if (record.resetAt < now) {
      rateLimitStore.delete(key);
    }
  }
}, 5 * 60 * 1000);

export function authRateLimit(options: { windowMs?: number; maxAttempts?: number } = {}) {
  const windowMs = options.windowMs || 15 * 60 * 1000;
  const maxAttempts = options.maxAttempts || 5;
  
  return (req: Request, res: Response, next: NextFunction): void => {
    const key = `auth:${req.ip}:${req.path}`;
    const now = Date.now();
    
    let record = rateLimitStore.get(key);
    
    if (!record || record.resetAt < now) {
      record = { count: 1, resetAt: now + windowMs };
      rateLimitStore.set(key, record);
      return next();
    }
    
    record.count++;
    
    if (record.count > maxAttempts) {
      const retryAfter = Math.ceil((record.resetAt - now) / 1000);
      res.status(429)
        .set('Retry-After', String(retryAfter))
        .json({
          error: 'Too many attempts. Please try again later.',
          code: 'RATE_LIMITED',
          retryAfter,
        });
      return;
    }
    
    next();
  };
}

export function resetRateLimit(ip: string, path: string): void {
  rateLimitStore.delete(`auth:${ip}:${path}`);
}