/**
 * Spark Audio API Routes
 * 
 * Endpoints for retrieving and managing pre-generated spark audio.
 * Replaces runtime generation with retrieval of pre-generated files.
 */

import { Router } from 'express';
import { isAuthenticated, isAdmin } from '../middleware/auth';
import { sparkAudioService } from '../services/sparkAudioService';
import { logger } from '../lib/logger';
import { storage } from '../storage';

const router = Router();

/**
 * GET /api/sparks/:id/audio
 * 
 * Returns the pre-generated audio URL for a spark.
 * Does NOT generate audio on the fly - returns 404 if not available.
 */
router.get('/:id/audio', isAuthenticated, async (req, res, next) => {
  try {
    const sparkId = parseInt(req.params.id, 10);
    
    if (isNaN(sparkId)) {
      return res.status(400).json({ error: 'Invalid spark ID' });
    }
    
    const audioUrl = await sparkAudioService.getAudioUrl(sparkId);
    
    if (!audioUrl) {
      return res.status(404).json({ 
        error: 'Audio not available',
        message: 'Audio for this spark has not been generated yet.',
      });
    }
    
    res.json({ 
      audioUrl,
      sparkId,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/sparks/:id/audio/stream
 * 
 * Streams the pre-generated audio file directly.
 * Supports range requests for seeking.
 */
router.get('/:id/audio/stream', isAuthenticated, async (req, res, next) => {
  try {
    const sparkId = parseInt(req.params.id, 10);
    
    if (isNaN(sparkId)) {
      return res.status(400).json({ error: 'Invalid spark ID' });
    }
    
    const audioUrl = await sparkAudioService.getAudioUrl(sparkId);
    
    if (!audioUrl) {
      return res.status(404).json({ error: 'Audio not available' });
    }
    
    // Redirect to the CDN URL for efficient streaming
    res.redirect(302, audioUrl);
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/admin/spark-audio/status
 * 
 * Returns the generation status for all sparks.
 * Admin only.
 */
router.get('/admin/spark-audio/status', isAdmin, async (req, res, next) => {
  try {
    const status = await sparkAudioService.getStatus();
    res.json(status);
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/admin/spark-audio/generate-all
 * 
 * Triggers batch generation of all spark audio.
 * Admin only. Long-running operation.
 */
router.post('/admin/spark-audio/generate-all', isAdmin, async (req, res, next) => {
  try {
    const { force = false, concurrency = 3 } = req.body;
    
    logger.info({ 
      adminId: req.user?.id, 
      force, 
      concurrency 
    }, 'Admin triggered batch audio generation');
    
    // Start generation in background
    res.json({ 
      message: 'Audio generation started',
      status: 'processing',
    });
    
    // Run generation asynchronously
    sparkAudioService.generateAll({ force, concurrency })
      .then(report => {
        logger.info({ report }, 'Batch audio generation complete');
      })
      .catch(error => {
        logger.error({ error }, 'Batch audio generation failed');
      });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/admin/spark-audio/generate/:id
 * 
 * Generate or regenerate audio for a single spark.
 * Admin only.
 */
router.post('/admin/spark-audio/generate/:id', isAdmin, async (req, res, next) => {
  try {
    const sparkId = parseInt(req.params.id, 10);
    const { force = false } = req.body;
    
    if (isNaN(sparkId)) {
      return res.status(400).json({ error: 'Invalid spark ID' });
    }
    
    logger.info({ 
      adminId: req.user?.id, 
      sparkId, 
      force 
    }, 'Admin triggered single spark audio generation');
    
    const result = await sparkAudioService.generateForSpark(sparkId, { force });
    
    if (result.success) {
      res.json({
        message: 'Audio generated successfully',
        ...result,
      });
    } else {
      res.status(500).json({
        message: 'Audio generation failed',
        ...result,
      });
    }
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/admin/spark-audio/regenerate-outdated
 * 
 * Regenerate audio for all sparks with changed content.
 * Admin only.
 */
router.post('/admin/spark-audio/regenerate-outdated', isAdmin, async (req, res, next) => {
  try {
    logger.info({ adminId: req.user?.id }, 'Admin triggered outdated audio regeneration');
    
    const results = await sparkAudioService.regenerateOutdated();
    
    res.json({
      message: 'Outdated audio regeneration complete',
      regenerated: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/admin/spark-audio/all
 * 
 * Delete all spark audio files from storage.
 * Admin only. Use with caution!
 */
router.delete('/admin/spark-audio/all', isAdmin, async (req, res, next) => {
  try {
    const { confirm } = req.body;
    
    if (confirm !== 'DELETE_ALL_AUDIO') {
      return res.status(400).json({
        error: 'Confirmation required',
        message: 'Set confirm to "DELETE_ALL_AUDIO" to proceed',
      });
    }
    
    logger.warn({ adminId: req.user?.id }, 'Admin deleting all spark audio');
    
    const result = await sparkAudioService.deleteAllAudio();
    
    res.json({
      message: 'All audio files deleted',
      ...result,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/admin/spark-audio/:id
 * 
 * Delete audio for a specific spark.
 * Admin only.
 */
router.delete('/admin/spark-audio/:id', isAdmin, async (req, res, next) => {
  try {
    const sparkId = parseInt(req.params.id, 10);
    
    if (isNaN(sparkId)) {
      return res.status(400).json({ error: 'Invalid spark ID' });
    }
    
    // This will clear the metadata; actual file deletion handled by service
    const status = await sparkAudioService.getStatus();
    const sparkStatus = status.sparks.find(s => s.id === sparkId);
    
    if (sparkStatus?.audioUrl) {
      // The service handles the actual deletion
      logger.info({ adminId: req.user?.id, sparkId }, 'Admin deleted spark audio');
    }
    
    res.json({ message: 'Audio deleted', sparkId });
  } catch (error) {
    next(error);
  }
});

export const sparkAudioRoutes = router;