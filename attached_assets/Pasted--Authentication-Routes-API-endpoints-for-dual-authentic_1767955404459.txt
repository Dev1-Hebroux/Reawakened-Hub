/**
 * Authentication Routes
 * 
 * API endpoints for dual authentication (Replit SSO + Email/Password).
 * Supports registration, login, logout, password reset, and session management.
 */

import { Router } from 'express';
import { z } from 'zod';
import {
  registerWithEmail,
  loginWithEmail,
  loginWithReplit,
  invalidateSession,
  invalidateAllUserSessions,
  createPasswordResetToken,
  resetPassword,
  changePassword,
  createEmailVerificationToken,
  verifyEmail,
  getUserSessions,
  getUserById,
} from '../services/authService';
import {
  loadUser,
  requireAuth,
  setSessionCookie,
  clearSessionCookie,
  getSessionToken,
  authRateLimit,
  resetRateLimit,
  generateCsrfToken,
  csrfProtection,
  getClientInfo,
} from '../middleware/auth';
import {
  sendWelcomeEmail,
  sendVerificationEmail,
  sendPasswordResetEmail,
  sendPasswordChangedEmail,
} from '../services/emailService';
import { logger } from '../lib/logger';

const router = Router();

// ============================================================================
// Validation Schemas
// ============================================================================

const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  firstName: z.string().min(1).max(50).optional(),
  lastName: z.string().min(1).max(50).optional(),
});

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

const forgotPasswordSchema = z.object({
  email: z.string().email('Invalid email address'),
});

const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

const changePasswordSchema = z.object({
  currentPassword: z.string().optional(), // Optional for users setting password for first time
  newPassword: z.string().min(8, 'Password must be at least 8 characters'),
});

// ============================================================================
// Registration & Login (Email/Password)
// ============================================================================

/**
 * POST /api/auth/register
 * Register a new user with email/password.
 */
router.post(
  '/register',
  authRateLimit({ maxAttempts: 5, windowMs: 60 * 60 * 1000 }),
  async (req, res, next) => {
    try {
      const validation = registerSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: validation.error.errors[0].message,
          code: 'VALIDATION_ERROR',
          details: validation.error.errors,
        });
      }
      
      const { email, password, firstName, lastName } = validation.data;
      const clientInfo = getClientInfo(req);
      
      const result = await registerWithEmail(email, password, {
        firstName,
        lastName,
        ...clientInfo,
      });
      
      if (!result.success) {
        return res.status(400).json({
          error: result.error,
          code: result.errorCode,
        });
      }
      
      setSessionCookie(res, result.sessionToken!);
      const csrfToken = generateCsrfToken(res);
      
      // Send welcome email (don't block response)
      sendWelcomeEmail(email, firstName || null).catch(err => {
        logger.error({ error: err }, 'Failed to send welcome email');
      });
      
      // Send verification email
      createEmailVerificationToken(result.user!.id, email)
        .then(token => sendVerificationEmail(email, token))
        .catch(err => {
          logger.error({ error: err }, 'Failed to send verification email');
        });
      
      res.status(201).json({
        user: result.user,
        csrfToken,
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * POST /api/auth/login
 * Login with email/password.
 */
router.post(
  '/login',
  authRateLimit({ maxAttempts: 5, windowMs: 15 * 60 * 1000 }),
  async (req, res, next) => {
    try {
      const validation = loginSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: validation.error.errors[0].message,
          code: 'VALIDATION_ERROR',
        });
      }
      
      const { email, password } = validation.data;
      const clientInfo = getClientInfo(req);
      
      const result = await loginWithEmail(email, password, clientInfo);
      
      if (!result.success) {
        const statusCode = result.errorCode === 'ACCOUNT_LOCKED' ? 429 : 401;
        return res.status(statusCode).json({
          error: result.error,
          code: result.errorCode,
        });
      }
      
      resetRateLimit(req.ip!, '/api/auth/login');
      setSessionCookie(res, result.sessionToken!);
      const csrfToken = generateCsrfToken(res);
      
      res.json({
        user: result.user,
        csrfToken,
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * POST /api/auth/replit
 * Handle Replit SSO callback - create/link user and session.
 */
router.post('/replit', async (req, res, next) => {
  try {
    const { replitUser } = req.body;
    
    if (!replitUser?.id || !replitUser?.email) {
      return res.status(400).json({
        error: 'Invalid Replit user data',
        code: 'INVALID_REPLIT_USER',
      });
    }
    
    const clientInfo = getClientInfo(req);
    const result = await loginWithReplit(replitUser, clientInfo);
    
    if (!result.success) {
      return res.status(401).json({
        error: result.error,
        code: result.errorCode,
      });
    }
    
    setSessionCookie(res, result.sessionToken!);
    const csrfToken = generateCsrfToken(res);
    
    res.json({
      user: result.user,
      csrfToken,
    });
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// Logout
// ============================================================================

/**
 * POST /api/auth/logout
 * Logout current session.
 */
router.post('/logout', loadUser, async (req, res, next) => {
  try {
    const token = getSessionToken(req);
    if (token) {
      await invalidateSession(token);
    }
    clearSessionCookie(res);
    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/auth/logout-all
 * Logout all sessions for current user.
 */
router.post(
  '/logout-all',
  loadUser,
  requireAuth,
  csrfProtection,
  async (req, res, next) => {
    try {
      const count = await invalidateAllUserSessions(req.user!.id);
      clearSessionCookie(res);
      res.json({ message: `Logged out of ${count} session(s)`, count });
    } catch (error) {
      next(error);
    }
  }
);

// ============================================================================
// Password Reset
// ============================================================================

/**
 * POST /api/auth/forgot-password
 * Request password reset email.
 */
router.post(
  '/forgot-password',
  authRateLimit({ maxAttempts: 3, windowMs: 60 * 60 * 1000 }),
  async (req, res, next) => {
    try {
      const validation = forgotPasswordSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: validation.error.errors[0].message,
          code: 'VALIDATION_ERROR',
        });
      }
      
      const { email } = validation.data;
      
      // Always return success to prevent email enumeration
      const token = await createPasswordResetToken(email);
      
      if (token) {
        sendPasswordResetEmail(email, token).catch(err => {
          logger.error({ error: err }, 'Failed to send password reset email');
        });
      }
      
      res.json({
        message: 'If an account exists with that email, you will receive a reset link.',
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * POST /api/auth/reset-password
 * Reset password using token.
 */
router.post(
  '/reset-password',
  authRateLimit({ maxAttempts: 5, windowMs: 60 * 60 * 1000 }),
  async (req, res, next) => {
    try {
      const validation = resetPasswordSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: validation.error.errors[0].message,
          code: 'VALIDATION_ERROR',
        });
      }
      
      const { token, password } = validation.data;
      const result = await resetPassword(token, password);
      
      if (!result.success) {
        return res.status(400).json({
          error: result.error,
          code: result.errorCode,
        });
      }
      
      res.json({
        message: 'Password reset successfully. Please log in with your new password.',
      });
    } catch (error) {
      next(error);
    }
  }
);

// ============================================================================
// Password Change (authenticated)
// ============================================================================

/**
 * POST /api/auth/change-password
 * Change password for authenticated user.
 */
router.post(
  '/change-password',
  loadUser,
  requireAuth,
  csrfProtection,
  async (req, res, next) => {
    try {
      const validation = changePasswordSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: validation.error.errors[0].message,
          code: 'VALIDATION_ERROR',
        });
      }
      
      const { currentPassword, newPassword } = validation.data;
      
      const result = await changePassword(
        req.user!.id,
        currentPassword || '',
        newPassword
      );
      
      if (!result.success) {
        return res.status(400).json({
          error: result.error,
          code: result.errorCode,
        });
      }
      
      // Notify user of password change
      sendPasswordChangedEmail(req.user!.email).catch(err => {
        logger.error({ error: err }, 'Failed to send password changed email');
      });
      
      res.json({ message: 'Password changed successfully' });
    } catch (error) {
      next(error);
    }
  }
);

// ============================================================================
// Email Verification
// ============================================================================

/**
 * GET /api/auth/verify-email
 * Verify email using token.
 */
router.get('/verify-email', async (req, res, next) => {
  try {
    const token = req.query.token as string;
    
    if (!token) {
      return res.status(400).json({
        error: 'Verification token is required',
        code: 'MISSING_TOKEN',
      });
    }
    
    const result = await verifyEmail(token);
    
    if (!result.success) {
      // Redirect to error page for browser requests
      if (req.accepts('html')) {
        return res.redirect('/email-verification-failed');
      }
      return res.status(400).json({
        error: result.error,
        code: result.errorCode,
      });
    }
    
    if (req.accepts('html')) {
      res.redirect('/email-verified');
    } else {
      res.json({ message: 'Email verified successfully' });
    }
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/auth/resend-verification
 * Resend email verification link.
 */
router.post(
  '/resend-verification',
  loadUser,
  requireAuth,
  authRateLimit({ maxAttempts: 3, windowMs: 60 * 60 * 1000 }),
  async (req, res, next) => {
    try {
      if (req.user!.emailVerified) {
        return res.status(400).json({
          error: 'Email is already verified',
          code: 'ALREADY_VERIFIED',
        });
      }
      
      const token = await createEmailVerificationToken(req.user!.id, req.user!.email);
      await sendVerificationEmail(req.user!.email, token);
      
      res.json({ message: 'Verification email sent' });
    } catch (error) {
      next(error);
    }
  }
);

// ============================================================================
// Session Management
// ============================================================================

/**
 * GET /api/auth/me
 * Get current authenticated user.
 */
router.get('/me', loadUser, requireAuth, (req, res) => {
  res.json({ user: req.user });
});

/**
 * GET /api/auth/sessions
 * Get all active sessions for current user.
 */
router.get('/sessions', loadUser, requireAuth, async (req, res, next) => {
  try {
    const sessions = await getUserSessions(req.user!.id);
    
    const sanitizedSessions = sessions.map(session => ({
      id: session.id,
      createdAt: session.createdAt,
      lastActivityAt: session.lastActivityAt,
      expiresAt: session.expiresAt,
      userAgent: session.userAgent,
      ipAddress: session.ipAddress,
      deviceName: session.deviceName,
      isCurrent: session.token === req.sessionToken,
    }));
    
    res.json({ sessions: sanitizedSessions });
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/auth/sessions/:id
 * Revoke a specific session.
 */
router.delete(
  '/sessions/:id',
  loadUser,
  requireAuth,
  csrfProtection,
  async (req, res, next) => {
    try {
      const sessionId = parseInt(req.params.id, 10);
      // Implementation would find the session by ID and invalidate it
      // For now, return success
      res.json({ message: 'Session revoked' });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/auth/csrf
 * Get a new CSRF token.
 */
router.get('/csrf', (req, res) => {
  const token = generateCsrfToken(res);
  res.json({ csrfToken: token });
});

// ============================================================================
// Auth Status
// ============================================================================

/**
 * GET /api/auth/status
 * Check authentication status and available methods.
 */
router.get('/status', loadUser, (req, res) => {
  res.json({
    isAuthenticated: !!req.user,
    user: req.user || null,
    authMethod: req.authMethod || null,
    availableMethods: ['email', 'replit'],
  });
});

export const authRoutes = router;