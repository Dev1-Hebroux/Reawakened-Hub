/**
 * Authentication Service
 * 
 * Core authentication logic including password hashing, session management,
 * and user verification. Uses bcrypt for secure password hashing and
 * crypto for session token generation.
 */

import bcrypt from 'bcrypt';
import crypto from 'crypto';
import { db } from '../db';
import { users, sessions, passwordResetTokens } from '@shared/schema';
import { eq, and, gt, lt } from 'drizzle-orm';
import { logger } from '../lib/logger';

// Configuration
const BCRYPT_ROUNDS = 12;
const SESSION_DURATION_DAYS = 30;
const SESSION_REFRESH_THRESHOLD_DAYS = 7;
const PASSWORD_RESET_EXPIRY_HOURS = 24;
const MIN_PASSWORD_LENGTH = 8;

// ============================================================================
// Types
// ============================================================================

export interface User {
  id: number;
  email: string;
  firstName: string | null;
  lastName: string | null;
  role: 'user' | 'admin' | 'moderator';
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface Session {
  id: number;
  userId: number;
  token: string;
  expiresAt: Date;
  createdAt: Date;
  lastActivityAt: Date;
  userAgent: string | null;
  ipAddress: string | null;
}

export interface AuthResult {
  success: boolean;
  user?: User;
  session?: Session;
  error?: string;
  errorCode?: string;
}

export interface PasswordValidation {
  isValid: boolean;
  errors: string[];
}

// ============================================================================
// Password Utilities
// ============================================================================

/**
 * Hash a password using bcrypt.
 */
export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, BCRYPT_ROUNDS);
}

/**
 * Verify a password against a hash.
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

/**
 * Validate password strength requirements.
 */
export function validatePassword(password: string): PasswordValidation {
  const errors: string[] = [];
  
  if (password.length < MIN_PASSWORD_LENGTH) {
    errors.push(`Password must be at least ${MIN_PASSWORD_LENGTH} characters long`);
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Generate a secure random token.
 */
export function generateToken(length: number = 32): string {
  return crypto.randomBytes(length).toString('hex');
}

/**
 * Generate a secure session token.
 */
export function generateSessionToken(): string {
  return generateToken(32);
}

// ============================================================================
// Session Management
// ============================================================================

/**
 * Create a new session for a user.
 */
export async function createSession(
  userId: number,
  options: { userAgent?: string; ipAddress?: string } = {}
): Promise<Session> {
  const token = generateSessionToken();
  const expiresAt = new Date(Date.now() + SESSION_DURATION_DAYS * 24 * 60 * 60 * 1000);
  
  const [session] = await db
    .insert(sessions)
    .values({
      userId,
      token,
      expiresAt,
      userAgent: options.userAgent || null,
      ipAddress: options.ipAddress || null,
      lastActivityAt: new Date(),
    })
    .returning();
  
  logger.info({ userId, sessionId: session.id }, 'Session created');
  
  return session;
}

/**
 * Validate a session token and return the associated session.
 */
export async function validateSession(token: string): Promise<Session | null> {
  const [session] = await db
    .select()
    .from(sessions)
    .where(
      and(
        eq(sessions.token, token),
        gt(sessions.expiresAt, new Date())
      )
    )
    .limit(1);
  
  if (!session) {
    return null;
  }
  
  // Refresh session if approaching expiration
  const refreshThreshold = new Date(
    Date.now() + SESSION_REFRESH_THRESHOLD_DAYS * 24 * 60 * 60 * 1000
  );
  
  if (session.expiresAt < refreshThreshold) {
    const newExpiresAt = new Date(
      Date.now() + SESSION_DURATION_DAYS * 24 * 60 * 60 * 1000
    );
    
    await db
      .update(sessions)
      .set({ 
        expiresAt: newExpiresAt,
        lastActivityAt: new Date(),
      })
      .where(eq(sessions.id, session.id));
    
    session.expiresAt = newExpiresAt;
  } else {
    // Update last activity
    await db
      .update(sessions)
      .set({ lastActivityAt: new Date() })
      .where(eq(sessions.id, session.id));
  }
  
  return session;
}

/**
 * Invalidate a session (logout).
 */
export async function invalidateSession(token: string): Promise<void> {
  await db
    .delete(sessions)
    .where(eq(sessions.token, token));
  
  logger.info('Session invalidated');
}

/**
 * Invalidate all sessions for a user (logout everywhere).
 */
export async function invalidateAllUserSessions(userId: number): Promise<number> {
  const result = await db
    .delete(sessions)
    .where(eq(sessions.userId, userId))
    .returning();
  
  logger.info({ userId, count: result.length }, 'All user sessions invalidated');
  
  return result.length;
}

/**
 * Clean up expired sessions (run periodically).
 */
export async function cleanupExpiredSessions(): Promise<number> {
  const result = await db
    .delete(sessions)
    .where(lt(sessions.expiresAt, new Date()))
    .returning();
  
  if (result.length > 0) {
    logger.info({ count: result.length }, 'Expired sessions cleaned up');
  }
  
  return result.length;
}

// ============================================================================
// User Authentication
// ============================================================================

/**
 * Register a new user.
 */
export async function registerUser(
  email: string,
  password: string,
  options: {
    firstName?: string;
    lastName?: string;
    userAgent?: string;
    ipAddress?: string;
  } = {}
): Promise<AuthResult> {
  // Normalize email
  const normalizedEmail = email.toLowerCase().trim();
  
  // Validate password
  const passwordValidation = validatePassword(password);
  if (!passwordValidation.isValid) {
    return {
      success: false,
      error: passwordValidation.errors[0],
      errorCode: 'WEAK_PASSWORD',
    };
  }
  
  // Check if user exists
  const [existingUser] = await db
    .select({ id: users.id })
    .from(users)
    .where(eq(users.email, normalizedEmail))
    .limit(1);
  
  if (existingUser) {
    return {
      success: false,
      error: 'An account with this email already exists',
      errorCode: 'EMAIL_EXISTS',
    };
  }
  
  // Hash password and create user
  const passwordHash = await hashPassword(password);
  
  const [newUser] = await db
    .insert(users)
    .values({
      email: normalizedEmail,
      passwordHash,
      firstName: options.firstName || null,
      lastName: options.lastName || null,
      role: 'user',
      emailVerified: false,
    })
    .returning();
  
  // Create session
  const session = await createSession(newUser.id, {
    userAgent: options.userAgent,
    ipAddress: options.ipAddress,
  });
  
  logger.info({ userId: newUser.id, email: normalizedEmail }, 'User registered');
  
  return {
    success: true,
    user: sanitizeUser(newUser),
    session,
  };
}

/**
 * Authenticate a user with email and password.
 */
export async function loginUser(
  email: string,
  password: string,
  options: {
    userAgent?: string;
    ipAddress?: string;
  } = {}
): Promise<AuthResult> {
  const normalizedEmail = email.toLowerCase().trim();
  
  // Find user
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.email, normalizedEmail))
    .limit(1);
  
  if (!user) {
    // Use same error message to prevent email enumeration
    return {
      success: false,
      error: 'Invalid email or password',
      errorCode: 'INVALID_CREDENTIALS',
    };
  }
  
  // Check if account is disabled
  if (user.isDisabled) {
    return {
      success: false,
      error: 'This account has been disabled',
      errorCode: 'ACCOUNT_DISABLED',
    };
  }
  
  // Verify password
  const isValidPassword = await verifyPassword(password, user.passwordHash);
  
  if (!isValidPassword) {
    logger.warn({ email: normalizedEmail }, 'Failed login attempt');
    
    return {
      success: false,
      error: 'Invalid email or password',
      errorCode: 'INVALID_CREDENTIALS',
    };
  }
  
  // Create session
  const session = await createSession(user.id, {
    userAgent: options.userAgent,
    ipAddress: options.ipAddress,
  });
  
  // Update last login
  await db
    .update(users)
    .set({ lastLoginAt: new Date() })
    .where(eq(users.id, user.id));
  
  logger.info({ userId: user.id, email: normalizedEmail }, 'User logged in');
  
  return {
    success: true,
    user: sanitizeUser(user),
    session,
  };
}

/**
 * Get user by session token.
 */
export async function getUserBySession(token: string): Promise<User | null> {
  const session = await validateSession(token);
  
  if (!session) {
    return null;
  }
  
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, session.userId))
    .limit(1);
  
  if (!user || user.isDisabled) {
    return null;
  }
  
  return sanitizeUser(user);
}

/**
 * Get user by ID.
 */
export async function getUserById(id: number): Promise<User | null> {
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, id))
    .limit(1);
  
  if (!user) {
    return null;
  }
  
  return sanitizeUser(user);
}

// ============================================================================
// Password Reset
// ============================================================================

/**
 * Create a password reset token.
 */
export async function createPasswordResetToken(email: string): Promise<string | null> {
  const normalizedEmail = email.toLowerCase().trim();
  
  // Find user
  const [user] = await db
    .select({ id: users.id })
    .from(users)
    .where(eq(users.email, normalizedEmail))
    .limit(1);
  
  if (!user) {
    // Return null but don't reveal that user doesn't exist
    return null;
  }
  
  // Delete any existing tokens for this user
  await db
    .delete(passwordResetTokens)
    .where(eq(passwordResetTokens.userId, user.id));
  
  // Create new token
  const token = generateToken(32);
  const expiresAt = new Date(
    Date.now() + PASSWORD_RESET_EXPIRY_HOURS * 60 * 60 * 1000
  );
  
  await db
    .insert(passwordResetTokens)
    .values({
      userId: user.id,
      token,
      expiresAt,
    });
  
  logger.info({ userId: user.id }, 'Password reset token created');
  
  return token;
}

/**
 * Reset password using a token.
 */
export async function resetPassword(
  token: string,
  newPassword: string
): Promise<AuthResult> {
  // Validate password
  const passwordValidation = validatePassword(newPassword);
  if (!passwordValidation.isValid) {
    return {
      success: false,
      error: passwordValidation.errors[0],
      errorCode: 'WEAK_PASSWORD',
    };
  }
  
  // Find valid token
  const [resetToken] = await db
    .select()
    .from(passwordResetTokens)
    .where(
      and(
        eq(passwordResetTokens.token, token),
        gt(passwordResetTokens.expiresAt, new Date())
      )
    )
    .limit(1);
  
  if (!resetToken) {
    return {
      success: false,
      error: 'Invalid or expired reset link',
      errorCode: 'INVALID_TOKEN',
    };
  }
  
  // Hash new password
  const passwordHash = await hashPassword(newPassword);
  
  // Update user password
  await db
    .update(users)
    .set({ 
      passwordHash,
      updatedAt: new Date(),
    })
    .where(eq(users.id, resetToken.userId));
  
  // Delete the used token
  await db
    .delete(passwordResetTokens)
    .where(eq(passwordResetTokens.id, resetToken.id));
  
  // Invalidate all existing sessions
  await invalidateAllUserSessions(resetToken.userId);
  
  logger.info({ userId: resetToken.userId }, 'Password reset completed');
  
  return {
    success: true,
  };
}

// ============================================================================
// Password Change (for logged-in users)
// ============================================================================

/**
 * Change password for an authenticated user.
 */
export async function changePassword(
  userId: number,
  currentPassword: string,
  newPassword: string
): Promise<AuthResult> {
  // Get user
  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.id, userId))
    .limit(1);
  
  if (!user) {
    return {
      success: false,
      error: 'User not found',
      errorCode: 'USER_NOT_FOUND',
    };
  }
  
  // Verify current password
  const isValidPassword = await verifyPassword(currentPassword, user.passwordHash);
  
  if (!isValidPassword) {
    return {
      success: false,
      error: 'Current password is incorrect',
      errorCode: 'INVALID_PASSWORD',
    };
  }
  
  // Validate new password
  const passwordValidation = validatePassword(newPassword);
  if (!passwordValidation.isValid) {
    return {
      success: false,
      error: passwordValidation.errors[0],
      errorCode: 'WEAK_PASSWORD',
    };
  }
  
  // Check new password is different
  const isSamePassword = await verifyPassword(newPassword, user.passwordHash);
  if (isSamePassword) {
    return {
      success: false,
      error: 'New password must be different from current password',
      errorCode: 'SAME_PASSWORD',
    };
  }
  
  // Hash and update
  const passwordHash = await hashPassword(newPassword);
  
  await db
    .update(users)
    .set({ 
      passwordHash,
      updatedAt: new Date(),
    })
    .where(eq(users.id, userId));
  
  logger.info({ userId }, 'Password changed');
  
  return {
    success: true,
  };
}

// ============================================================================
// Email Verification
// ============================================================================

/**
 * Create an email verification token.
 */
export async function createEmailVerificationToken(userId: number): Promise<string> {
  const token = generateToken(32);
  const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
  
  await db
    .update(users)
    .set({ 
      emailVerificationToken: token,
      emailVerificationExpires: expiresAt,
    })
    .where(eq(users.id, userId));
  
  return token;
}

/**
 * Verify email using token.
 */
export async function verifyEmail(token: string): Promise<AuthResult> {
  const [user] = await db
    .select()
    .from(users)
    .where(
      and(
        eq(users.emailVerificationToken, token),
        gt(users.emailVerificationExpires, new Date())
      )
    )
    .limit(1);
  
  if (!user) {
    return {
      success: false,
      error: 'Invalid or expired verification link',
      errorCode: 'INVALID_TOKEN',
    };
  }
  
  await db
    .update(users)
    .set({
      emailVerified: true,
      emailVerificationToken: null,
      emailVerificationExpires: null,
      updatedAt: new Date(),
    })
    .where(eq(users.id, user.id));
  
  logger.info({ userId: user.id }, 'Email verified');
  
  return {
    success: true,
    user: sanitizeUser({ ...user, emailVerified: true }),
  };
}

// ============================================================================
// Utilities
// ============================================================================

/**
 * Remove sensitive fields from user object.
 */
function sanitizeUser(user: any): User {
  return {
    id: user.id,
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
    role: user.role,
    emailVerified: user.emailVerified,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt,
  };
}

/**
 * Get active sessions for a user.
 */
export async function getUserSessions(userId: number): Promise<Session[]> {
  return db
    .select()
    .from(sessions)
    .where(
      and(
        eq(sessions.userId, userId),
        gt(sessions.expiresAt, new Date())
      )
    )
    .orderBy(sessions.lastActivityAt);
}