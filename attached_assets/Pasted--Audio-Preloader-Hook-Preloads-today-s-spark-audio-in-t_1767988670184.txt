/**
 * Audio Preloader Hook
 * 
 * Preloads today's spark audio in the background after page load,
 * so playback starts instantly when users tap the play button.
 */

import { useEffect, useRef, useCallback, useState } from 'react';
import { useDashboard } from './useDashboard';

// ============================================================================
// Types
// ============================================================================

interface PreloadedAudio {
  url: string;
  audio: HTMLAudioElement;
  duration: number;
  ready: boolean;
}

interface UseAudioPreloaderReturn {
  /** Whether the audio is preloaded and ready to play */
  isReady: boolean;
  /** Audio duration in seconds (0 if not loaded) */
  duration: number;
  /** Play the preloaded audio */
  play: () => Promise<void>;
  /** Pause playback */
  pause: () => void;
  /** Current playback time in seconds */
  currentTime: number;
  /** Whether audio is currently playing */
  isPlaying: boolean;
  /** Seek to a specific time */
  seekTo: (time: number) => void;
  /** Loading/error state */
  status: 'idle' | 'loading' | 'ready' | 'error';
  /** Error message if failed to load */
  error: string | null;
}

// ============================================================================
// Audio Cache
// ============================================================================

// Global cache to persist across component remounts
const audioCache = new Map<string, PreloadedAudio>();

function getCachedAudio(url: string): PreloadedAudio | null {
  return audioCache.get(url) || null;
}

function setCachedAudio(url: string, audio: PreloadedAudio): void {
  // Limit cache size
  if (audioCache.size > 5) {
    const firstKey = audioCache.keys().next().value;
    const old = audioCache.get(firstKey);
    if (old) {
      old.audio.src = ''; // Release memory
    }
    audioCache.delete(firstKey);
  }
  audioCache.set(url, audio);
}

// ============================================================================
// Preloader Hook
// ============================================================================

export function useAudioPreloader(audioUrl: string | null | undefined): UseAudioPreloaderReturn {
  const [status, setStatus] = useState<'idle' | 'loading' | 'ready' | 'error'>('idle');
  const [error, setError] = useState<string | null>(null);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const timeUpdateRef = useRef<number>();

  // Preload audio when URL changes
  useEffect(() => {
    if (!audioUrl) {
      setStatus('idle');
      return;
    }

    // Check cache first
    const cached = getCachedAudio(audioUrl);
    if (cached?.ready) {
      audioRef.current = cached.audio;
      setDuration(cached.duration);
      setStatus('ready');
      return;
    }

    // Start loading
    setStatus('loading');
    setError(null);

    const audio = new Audio();
    audioRef.current = audio;
    
    // Preload metadata first (faster), then full audio
    audio.preload = 'auto';
    
    const handleLoadedMetadata = () => {
      setDuration(audio.duration);
    };

    const handleCanPlayThrough = () => {
      setStatus('ready');
      setCachedAudio(audioUrl, {
        url: audioUrl,
        audio,
        duration: audio.duration,
        ready: true,
      });
    };

    const handleError = () => {
      setStatus('error');
      setError('Failed to load audio');
    };

    const handleEnded = () => {
      setIsPlaying(false);
      setCurrentTime(0);
    };

    const handleTimeUpdate = () => {
      setCurrentTime(audio.currentTime);
    };

    audio.addEventListener('loadedmetadata', handleLoadedMetadata);
    audio.addEventListener('canplaythrough', handleCanPlayThrough);
    audio.addEventListener('error', handleError);
    audio.addEventListener('ended', handleEnded);
    audio.addEventListener('timeupdate', handleTimeUpdate);

    // Start loading
    audio.src = audioUrl;
    audio.load();

    return () => {
      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
      audio.removeEventListener('canplaythrough', handleCanPlayThrough);
      audio.removeEventListener('error', handleError);
      audio.removeEventListener('ended', handleEnded);
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      
      // Don't remove from cache on unmount
    };
  }, [audioUrl]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeUpdateRef.current) {
        cancelAnimationFrame(timeUpdateRef.current);
      }
    };
  }, []);

  const play = useCallback(async () => {
    if (!audioRef.current) return;
    
    try {
      await audioRef.current.play();
      setIsPlaying(true);
    } catch (err) {
      // Handle autoplay restrictions
      setError('Tap to play audio');
    }
  }, []);

  const pause = useCallback(() => {
    if (!audioRef.current) return;
    audioRef.current.pause();
    setIsPlaying(false);
  }, []);

  const seekTo = useCallback((time: number) => {
    if (!audioRef.current) return;
    audioRef.current.currentTime = Math.max(0, Math.min(time, duration));
    setCurrentTime(audioRef.current.currentTime);
  }, [duration]);

  return {
    isReady: status === 'ready',
    duration,
    play,
    pause,
    currentTime,
    isPlaying,
    seekTo,
    status,
    error,
  };
}

// ============================================================================
// Dashboard Audio Preloader
// ============================================================================

/**
 * Hook that automatically preloads today's spark audio.
 * Use this at the app level to start preloading early.
 */
export function useTodaySparkAudioPreloader() {
  const { todaySpark } = useDashboard();
  return useAudioPreloader(todaySpark?.audioUrl);
}

// ============================================================================
// Preload Component
// ============================================================================

/**
 * Invisible component that preloads audio in the background.
 * Add this to your App or Dashboard layout.
 * 
 * Usage:
 * ```tsx
 * function App() {
 *   return (
 *     <>
 *       <AudioPreloader />
 *       <Routes />
 *     </>
 *   );
 * }
 * ```
 */
export function AudioPreloader(): null {
  useTodaySparkAudioPreloader();
  return null;
}

// ============================================================================
// Audio Player Component Example
// ============================================================================

/*
Usage example:

function SparkAudioPlayer({ audioUrl }: { audioUrl: string }) {
  const {
    isReady,
    duration,
    play,
    pause,
    currentTime,
    isPlaying,
    seekTo,
    status,
  } = useAudioPreloader(audioUrl);

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="audio-player">
      <button 
        onClick={isPlaying ? pause : play}
        disabled={!isReady}
      >
        {status === 'loading' && <Spinner />}
        {isPlaying ? <PauseIcon /> : <PlayIcon />}
      </button>
      
      <input
        type="range"
        min={0}
        max={duration}
        value={currentTime}
        onChange={(e) => seekTo(Number(e.target.value))}
        disabled={!isReady}
      />
      
      <span>{formatTime(currentTime)} / {formatTime(duration)}</span>
    </div>
  );
}
*/