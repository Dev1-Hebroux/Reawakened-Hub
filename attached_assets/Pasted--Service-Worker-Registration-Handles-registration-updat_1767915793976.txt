/**
 * Service Worker Registration
 * 
 * Handles registration, updates, and communication with the service worker.
 * Include this in your application entry point.
 */

// ============================================================================
// Configuration
// ============================================================================

const SW_PATH = '/sw.js';
const SW_SCOPE = '/';

// ============================================================================
// Registration
// ============================================================================

export async function registerServiceWorker(): Promise<ServiceWorkerRegistration | null> {
  if (!('serviceWorker' in navigator)) {
    console.log('Service workers not supported');
    return null;
  }

  try {
    const registration = await navigator.serviceWorker.register(SW_PATH, {
      scope: SW_SCOPE,
    });

    console.log('Service Worker registered:', registration.scope);

    // Handle updates
    registration.addEventListener('updatefound', () => {
      const newWorker = registration.installing;
      
      if (newWorker) {
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            // New content available, notify user
            dispatchUpdateEvent();
          }
        });
      }
    });

    return registration;
  } catch (error) {
    console.error('Service Worker registration failed:', error);
    return null;
  }
}

// ============================================================================
// Update Handling
// ============================================================================

/**
 * Check for service worker updates.
 */
export async function checkForUpdates(): Promise<void> {
  const registration = await navigator.serviceWorker.getRegistration();
  
  if (registration) {
    await registration.update();
  }
}

/**
 * Skip waiting and activate new service worker.
 */
export async function activateUpdate(): Promise<void> {
  const registration = await navigator.serviceWorker.getRegistration();
  
  if (registration?.waiting) {
    registration.waiting.postMessage({ type: 'SKIP_WAITING' });
  }
}

/**
 * Dispatch custom event when update is available.
 */
function dispatchUpdateEvent(): void {
  window.dispatchEvent(new CustomEvent('sw-update-available'));
}

// ============================================================================
// Message Communication
// ============================================================================

/**
 * Send a message to the service worker.
 */
export function sendMessage(message: { type: string; payload?: unknown }): void {
  navigator.serviceWorker.controller?.postMessage(message);
}

/**
 * Send a message and wait for response.
 */
export function sendMessageWithResponse<T>(
  message: { type: string; payload?: unknown }
): Promise<T> {
  return new Promise((resolve, reject) => {
    const channel = new MessageChannel();
    
    channel.port1.onmessage = (event) => {
      if (event.data.error) {
        reject(new Error(event.data.error));
      } else {
        resolve(event.data as T);
      }
    };
    
    navigator.serviceWorker.controller?.postMessage(message, [channel.port2]);
  });
}

// ============================================================================
// Cache Management
// ============================================================================

/**
 * Request the service worker to cache specific content.
 */
export function cacheContent(type: string, id: number, url: string): void {
  sendMessage({
    type: 'CACHE_CONTENT',
    payload: { type, id, url },
  });
}

/**
 * Get cache status from service worker.
 */
export async function getCacheStatus(): Promise<Record<string, number>> {
  return sendMessageWithResponse({ type: 'GET_CACHE_STATUS' });
}

/**
 * Clear all caches.
 */
export function clearCaches(): void {
  sendMessage({ type: 'CLEAR_CACHE' });
}

// ============================================================================
// Push Notification Setup
// ============================================================================

/**
 * Request push notification permission and subscribe.
 */
export async function subscribeToPushNotifications(
  vapidPublicKey: string
): Promise<PushSubscription | null> {
  if (!('PushManager' in window)) {
    console.log('Push notifications not supported');
    return null;
  }

  const permission = await Notification.requestPermission();
  
  if (permission !== 'granted') {
    console.log('Push notification permission denied');
    return null;
  }

  const registration = await navigator.serviceWorker.getRegistration();
  
  if (!registration) {
    console.error('No service worker registration');
    return null;
  }

  try {
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });

    console.log('Push subscription created:', subscription.endpoint);
    return subscription;
  } catch (error) {
    console.error('Push subscription failed:', error);
    return null;
  }
}

/**
 * Get existing push subscription.
 */
export async function getPushSubscription(): Promise<PushSubscription | null> {
  const registration = await navigator.serviceWorker.getRegistration();
  
  if (!registration) {
    return null;
  }

  return registration.pushManager.getSubscription();
}

/**
 * Unsubscribe from push notifications.
 */
export async function unsubscribeFromPush(): Promise<boolean> {
  const subscription = await getPushSubscription();
  
  if (!subscription) {
    return true;
  }

  return subscription.unsubscribe();
}

// ============================================================================
// Utility Functions
// ============================================================================

function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }

  return outputArray;
}

// ============================================================================
// React Hook for Service Worker
// ============================================================================

import { useState, useEffect, useCallback } from 'react';

export function useServiceWorker() {
  const [registration, setRegistration] = useState<ServiceWorkerRegistration | null>(null);
  const [updateAvailable, setUpdateAvailable] = useState(false);
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    registerServiceWorker().then(setRegistration);

    const handleUpdate = () => setUpdateAvailable(true);
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('sw-update-available', handleUpdate);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('sw-update-available', handleUpdate);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  const applyUpdate = useCallback(async () => {
    await activateUpdate();
    window.location.reload();
  }, []);

  return {
    registration,
    updateAvailable,
    isOnline,
    applyUpdate,
    checkForUpdates,
  };
}