/**
 * Optimized Dashboard Hook
 * 
 * Features:
 * - Stale-while-revalidate pattern
 * - Persistent cache across sessions
 * - Graceful offline handling
 * - Optimistic updates
 */

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useCallback, useEffect } from 'react';
import type { Spark, ReflectionCard, PrayerSession } from '@shared/schema';

// ============================================================================
// TYPES
// ============================================================================

interface DashboardData {
  sparks: Spark[];
  todaySpark: Spark | null;
  featured: Spark[];
  reflection: ReflectionCard | null;
  sessions: PrayerSession[];
  meta: {
    timestamp: string;
    audienceSegment: string | null;
    totalSparks: number;
    offline?: boolean;
  };
}

interface UseDashboardOptions {
  userAudienceSegment?: string | null;
  enabled?: boolean;
}

interface UseDashboardReturn {
  data: DashboardData | undefined;
  sparks: Spark[];
  todaySpark: Spark | null;
  featured: Spark[];
  reflection: ReflectionCard | null;
  sessions: PrayerSession[];
  isLoading: boolean;
  isError: boolean;
  isOffline: boolean;
  error: Error | null;
  refetch: () => void;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const CACHE_KEY_PREFIX = '/api/sparks/dashboard';
const STALE_TIME = 5 * 60 * 1000;        // 5 minutes - data considered fresh
const GC_TIME = 24 * 60 * 60 * 1000;     // 24 hours - keep in memory
const RETRY_COUNT = 3;
const RETRY_DELAY_BASE = 1000;

// ============================================================================
// HELPERS
// ============================================================================

function getEffectiveAudience(userSegment?: string | null): string | null {
  if (!userSegment) return null;
  const validSegments = ['schools', 'universities', 'early-career', 'builders', 'couples'];
  return validSegments.includes(userSegment) ? userSegment : null;
}

function buildApiUrl(audience: string | null): string {
  const baseUrl = '/api/sparks/dashboard';
  return audience ? `${baseUrl}?audience=${audience}` : baseUrl;
}

async function fetchDashboard(audience: string | null): Promise<DashboardData> {
  const response = await fetch(buildApiUrl(audience), {
    headers: {
      'Accept': 'application/json',
    },
    credentials: 'include',
  });
  
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || `Failed to load dashboard: ${response.status}`);
  }
  
  return response.json();
}

// ============================================================================
// PERSISTENCE (LocalStorage)
// ============================================================================

const STORAGE_KEY = 'dashboard-cache';

function persistToStorage(audience: string | null, data: DashboardData): void {
  try {
    const cached = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    cached[audience || 'default'] = {
      data,
      timestamp: Date.now(),
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(cached));
  } catch {
    // Storage full or unavailable, ignore
  }
}

function getFromStorage(audience: string | null): DashboardData | undefined {
  try {
    const cached = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    const entry = cached[audience || 'default'];
    
    if (entry && Date.now() - entry.timestamp < GC_TIME) {
      return entry.data;
    }
  } catch {
    // Corrupted storage, ignore
  }
  return undefined;
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export function useDashboard(options: UseDashboardOptions = {}): UseDashboardReturn {
  const { userAudienceSegment, enabled = true } = options;
  const queryClient = useQueryClient();
  
  const effectiveAudience = getEffectiveAudience(userAudienceSegment);
  const queryKey = [CACHE_KEY_PREFIX, effectiveAudience];
  
  // Get persisted data for initial render
  const persistedData = getFromStorage(effectiveAudience);
  
  const query = useQuery<DashboardData>({
    queryKey,
    queryFn: () => fetchDashboard(effectiveAudience),
    enabled,
    
    // Stale-while-revalidate configuration
    staleTime: STALE_TIME,
    gcTime: GC_TIME,
    
    // Use persisted data as placeholder for instant render
    placeholderData: persistedData,
    
    // Retry configuration
    retry: RETRY_COUNT,
    retryDelay: (attempt) => Math.min(RETRY_DELAY_BASE * Math.pow(2, attempt), 10000),
    
    // Keep previous data while refetching
    refetchOnWindowFocus: true,
    refetchOnReconnect: true,
    
    // Network mode
    networkMode: 'offlineFirst',
  });
  
  // Persist successful fetches
  useEffect(() => {
    if (query.data && !query.data.meta?.offline) {
      persistToStorage(effectiveAudience, query.data);
    }
  }, [query.data, effectiveAudience]);
  
  // Derived state
  const data = query.data;
  const isOffline = data?.meta?.offline === true;
  
  return {
    data,
    sparks: data?.sparks ?? [],
    todaySpark: data?.todaySpark ?? null,
    featured: data?.featured ?? [],
    reflection: data?.reflection ?? null,
    sessions: data?.sessions ?? [],
    isLoading: query.isLoading && !persistedData,
    isError: query.isError,
    isOffline,
    error: query.error,
    refetch: query.refetch,
  };
}

// ============================================================================
// PREFETCH HOOK
// ============================================================================

export function usePrefetchDashboard() {
  const queryClient = useQueryClient();
  
  return useCallback((audienceSegment?: string | null) => {
    const effectiveAudience = getEffectiveAudience(audienceSegment);
    const queryKey = [CACHE_KEY_PREFIX, effectiveAudience];
    
    queryClient.prefetchQuery({
      queryKey,
      queryFn: () => fetchDashboard(effectiveAudience),
      staleTime: STALE_TIME,
    });
  }, [queryClient]);
}

// ============================================================================
// INVALIDATION HELPERS
// ============================================================================

export function useInvalidateDashboard() {
  const queryClient = useQueryClient();
  
  return useCallback(() => {
    queryClient.invalidateQueries({ queryKey: [CACHE_KEY_PREFIX] });
  }, [queryClient]);
}

// ============================================================================
// SKELETON DATA (for loading states)
// ============================================================================

export const DASHBOARD_SKELETON: DashboardData = {
  sparks: [],
  todaySpark: null,
  featured: [],
  reflection: null,
  sessions: [],
  meta: {
    timestamp: new Date().toISOString(),
    audienceSegment: null,
    totalSparks: 0,
  },
};