/**
 * Spark Audio Pre-Generation Service
 * 
 * Handles batch generation and management of spark devotional audio files.
 * Ensures all audio is pre-generated with correct content alignment,
 * eliminating runtime generation and duplicate issues.
 */

import OpenAI from 'openai';
import { storage } from './storage';
import { db } from './db';
import { sparks } from '@shared/schema';
import { eq, isNotNull } from 'drizzle-orm';
import { createHash } from 'crypto';
import { Readable } from 'stream';
import { logger } from './lib/logger';

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Audio generation configuration
const TTS_CONFIG = {
  model: 'tts-1-hd' as const,
  voice: 'nova' as const,
  speed: 0.95,
  responseFormat: 'mp3' as const,
};

const AUDIO_STORAGE_PREFIX = 'audio/sparks';

// ============================================================================
// Types
// ============================================================================

interface SparkContent {
  id: number;
  title: string;
  scriptureReference: string;
  scriptureText: string;
  teaching: string;
  reflection: string;
  actionStep: string;
  prayer: string;
}

interface AudioMetadata {
  sparkId: number;
  contentHash: string;
  generatedAt: string;
  duration?: number;
  fileSize: number;
  storagePath: string;
  publicUrl: string;
}

interface GenerationResult {
  success: boolean;
  sparkId: number;
  error?: string;
  metadata?: AudioMetadata;
}

interface BatchGenerationReport {
  startedAt: string;
  completedAt: string;
  totalSparks: number;
  successful: number;
  failed: number;
  skipped: number;
  results: GenerationResult[];
}

// ============================================================================
// Content Hash Generation
// ============================================================================

/**
 * Generate a hash of the spark content to detect changes.
 * This ensures we only regenerate audio when content actually changes.
 */
function generateContentHash(spark: SparkContent): string {
  const contentString = [
    spark.title,
    spark.scriptureReference,
    spark.scriptureText,
    spark.teaching,
    spark.reflection,
    spark.actionStep,
    spark.prayer,
  ].join('|||');
  
  return createHash('sha256').update(contentString).digest('hex').substring(0, 16);
}

/**
 * Compose the full narration script from spark content.
 * Includes natural pauses and transitions for better listening experience.
 */
function composeNarrationScript(spark: SparkContent): string {
  const sections: string[] = [];
  
  // Title introduction
  sections.push(`Today's spark: ${spark.title}.`);
  sections.push(''); // Pause
  
  // Scripture reading
  sections.push(`Let's begin with Scripture from ${spark.scriptureReference}.`);
  sections.push(''); // Pause
  sections.push(spark.scriptureText);
  sections.push(''); // Longer pause after scripture
  sections.push('');
  
  // Teaching section
  sections.push(spark.teaching);
  sections.push(''); // Pause
  
  // Reflection
  if (spark.reflection) {
    sections.push('Take a moment to reflect.');
    sections.push(''); // Pause
    sections.push(spark.reflection);
    sections.push(''); // Pause
  }
  
  // Action step
  if (spark.actionStep) {
    sections.push('Here is your action step for today.');
    sections.push(''); // Pause
    sections.push(spark.actionStep);
    sections.push(''); // Pause
  }
  
  // Closing prayer
  if (spark.prayer) {
    sections.push("Let's close in prayer.");
    sections.push(''); // Pause
    sections.push(spark.prayer);
  }
  
  // Closing
  sections.push(''); // Pause
  sections.push('Amen. May this spark ignite your faith today.');
  
  return sections.join('\n');
}

// ============================================================================
// Audio Generation
// ============================================================================

/**
 * Generate TTS audio for a single spark.
 */
async function generateSparkAudio(spark: SparkContent): Promise<Buffer> {
  const script = composeNarrationScript(spark);
  
  logger.info({ sparkId: spark.id, scriptLength: script.length }, 'Generating TTS audio');
  
  const response = await openai.audio.speech.create({
    model: TTS_CONFIG.model,
    voice: TTS_CONFIG.voice,
    speed: TTS_CONFIG.speed,
    input: script,
    response_format: TTS_CONFIG.responseFormat,
  });
  
  const arrayBuffer = await response.arrayBuffer();
  return Buffer.from(arrayBuffer);
}

/**
 * Get the storage path for a spark's audio file.
 * Uses content hash to ensure correct version alignment.
 */
function getAudioStoragePath(sparkId: number, contentHash: string): string {
  return `${AUDIO_STORAGE_PREFIX}/spark-${sparkId}-${contentHash}.mp3`;
}

/**
 * Get the legacy storage path (without hash) for cleanup.
 */
function getLegacyAudioPath(sparkId: number): string {
  return `public/audio/spark-${sparkId}.mp3`;
}

// ============================================================================
// Storage Operations
// ============================================================================

/**
 * Upload audio buffer to object storage.
 */
async function uploadAudio(
  buffer: Buffer, 
  storagePath: string
): Promise<{ url: string; size: number }> {
  const uploadResult = await storage.upload(storagePath, buffer, {
    contentType: 'audio/mpeg',
    cacheControl: 'public, max-age=31536000', // 1 year cache
  });
  
  return {
    url: uploadResult.publicUrl,
    size: buffer.length,
  };
}

/**
 * Check if audio file exists in storage.
 */
async function audioExists(storagePath: string): Promise<boolean> {
  try {
    await storage.head(storagePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Delete audio file from storage.
 */
async function deleteAudio(storagePath: string): Promise<void> {
  try {
    await storage.delete(storagePath);
    logger.info({ storagePath }, 'Deleted audio file');
  } catch (error) {
    logger.warn({ storagePath, error }, 'Failed to delete audio file (may not exist)');
  }
}

/**
 * List all spark audio files in storage.
 */
async function listAllSparkAudio(): Promise<string[]> {
  const files = await storage.list(AUDIO_STORAGE_PREFIX);
  const legacyFiles = await storage.list('public/audio');
  
  return [
    ...files.filter(f => f.startsWith('spark-')),
    ...legacyFiles.filter(f => f.startsWith('spark-')),
  ];
}

// ============================================================================
// Database Operations
// ============================================================================

/**
 * Fetch all published sparks from the database.
 */
async function fetchAllSparks(): Promise<SparkContent[]> {
  const results = await db
    .select({
      id: sparks.id,
      title: sparks.title,
      scriptureReference: sparks.scriptureReference,
      scriptureText: sparks.scriptureText,
      teaching: sparks.teaching,
      reflection: sparks.reflection,
      actionStep: sparks.actionStep,
      prayer: sparks.prayer,
    })
    .from(sparks)
    .where(eq(sparks.isPublished, true))
    .orderBy(sparks.id);
  
  return results;
}

/**
 * Fetch a single spark by ID.
 */
async function fetchSparkById(sparkId: number): Promise<SparkContent | null> {
  const [result] = await db
    .select({
      id: sparks.id,
      title: sparks.title,
      scriptureReference: sparks.scriptureReference,
      scriptureText: sparks.scriptureText,
      teaching: sparks.teaching,
      reflection: sparks.reflection,
      actionStep: sparks.actionStep,
      prayer: sparks.prayer,
    })
    .from(sparks)
    .where(eq(sparks.id, sparkId))
    .limit(1);
  
  return result || null;
}

/**
 * Get stored audio metadata for a spark.
 */
async function getAudioMetadata(sparkId: number): Promise<AudioMetadata | null> {
  const [result] = await db
    .select({
      sparkId: sparks.id,
      audioMetadata: sparks.audioMetadata,
    })
    .from(sparks)
    .where(eq(sparks.id, sparkId))
    .limit(1);
  
  if (!result?.audioMetadata) return null;
  
  return result.audioMetadata as AudioMetadata;
}

/**
 * Save audio metadata to the database.
 */
async function saveAudioMetadata(sparkId: number, metadata: AudioMetadata): Promise<void> {
  await db
    .update(sparks)
    .set({ 
      audioMetadata: metadata,
      audioUrl: metadata.publicUrl,
      updatedAt: new Date(),
    })
    .where(eq(sparks.id, sparkId));
}

/**
 * Clear audio metadata from the database.
 */
async function clearAudioMetadata(sparkId: number): Promise<void> {
  await db
    .update(sparks)
    .set({ 
      audioMetadata: null,
      audioUrl: null,
      updatedAt: new Date(),
    })
    .where(eq(sparks.id, sparkId));
}

// ============================================================================
// Main Service Class
// ============================================================================

export class SparkAudioService {
  /**
   * Pre-generate audio for a single spark.
   * Skips generation if content hasn't changed.
   */
  async generateForSpark(
    sparkId: number, 
    options: { force?: boolean } = {}
  ): Promise<GenerationResult> {
    try {
      const spark = await fetchSparkById(sparkId);
      
      if (!spark) {
        return { 
          success: false, 
          sparkId, 
          error: 'Spark not found' 
        };
      }
      
      const contentHash = generateContentHash(spark);
      const storagePath = getAudioStoragePath(sparkId, contentHash);
      
      // Check if current version already exists
      if (!options.force) {
        const existingMetadata = await getAudioMetadata(sparkId);
        
        if (existingMetadata && existingMetadata.contentHash === contentHash) {
          // Verify file still exists in storage
          if (await audioExists(existingMetadata.storagePath)) {
            logger.info({ sparkId, contentHash }, 'Audio already exists and is current');
            return { 
              success: true, 
              sparkId, 
              metadata: existingMetadata 
            };
          }
        }
      }
      
      // Generate new audio
      logger.info({ sparkId, contentHash }, 'Generating new audio');
      const audioBuffer = await generateSparkAudio(spark);
      
      // Upload to storage
      const { url, size } = await uploadAudio(audioBuffer, storagePath);
      
      // Create metadata
      const metadata: AudioMetadata = {
        sparkId,
        contentHash,
        generatedAt: new Date().toISOString(),
        fileSize: size,
        storagePath,
        publicUrl: url,
      };
      
      // Save metadata to database
      await saveAudioMetadata(sparkId, metadata);
      
      logger.info({ sparkId, contentHash, size }, 'Audio generated successfully');
      
      return { success: true, sparkId, metadata };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      logger.error({ sparkId, error: errorMessage }, 'Failed to generate audio');
      
      return { 
        success: false, 
        sparkId, 
        error: errorMessage 
      };
    }
  }

  /**
   * Pre-generate audio for all sparks.
   * This is the main batch operation for initial setup and updates.
   */
  async generateAll(options: { 
    force?: boolean;
    concurrency?: number;
  } = {}): Promise<BatchGenerationReport> {
    const { force = false, concurrency = 3 } = options;
    const startedAt = new Date().toISOString();
    
    logger.info({ force, concurrency }, 'Starting batch audio generation');
    
    const allSparks = await fetchAllSparks();
    const results: GenerationResult[] = [];
    let successful = 0;
    let failed = 0;
    let skipped = 0;
    
    // Process in batches to avoid rate limiting
    for (let i = 0; i < allSparks.length; i += concurrency) {
      const batch = allSparks.slice(i, i + concurrency);
      
      const batchResults = await Promise.all(
        batch.map(spark => this.generateForSpark(spark.id, { force }))
      );
      
      for (const result of batchResults) {
        results.push(result);
        
        if (result.success) {
          if (result.metadata?.generatedAt === startedAt.substring(0, 10)) {
            successful++;
          } else {
            skipped++; // Already existed
          }
        } else {
          failed++;
        }
      }
      
      // Rate limiting pause between batches
      if (i + concurrency < allSparks.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      logger.info({ 
        processed: i + batch.length, 
        total: allSparks.length 
      }, 'Batch progress');
    }
    
    const completedAt = new Date().toISOString();
    
    const report: BatchGenerationReport = {
      startedAt,
      completedAt,
      totalSparks: allSparks.length,
      successful,
      failed,
      skipped,
      results,
    };
    
    logger.info({ 
      successful, 
      failed, 
      skipped, 
      total: allSparks.length 
    }, 'Batch generation complete');
    
    return report;
  }

  /**
   * Delete all existing spark audio files from storage.
   * Use before regenerating to ensure clean slate.
   */
  async deleteAllAudio(): Promise<{ deleted: number; errors: string[] }> {
    logger.info('Deleting all spark audio files');
    
    const files = await listAllSparkAudio();
    let deleted = 0;
    const errors: string[] = [];
    
    for (const file of files) {
      try {
        await deleteAudio(file);
        deleted++;
      } catch (error) {
        errors.push(`Failed to delete ${file}: ${error}`);
      }
    }
    
    // Clear all audio metadata from database
    await db
      .update(sparks)
      .set({ audioMetadata: null, audioUrl: null });
    
    logger.info({ deleted, errors: errors.length }, 'Audio cleanup complete');
    
    return { deleted, errors };
  }

  /**
   * Get audio URL for a spark.
   * Returns the pre-generated URL or null if not available.
   */
  async getAudioUrl(sparkId: number): Promise<string | null> {
    const metadata = await getAudioMetadata(sparkId);
    
    if (!metadata) {
      logger.warn({ sparkId }, 'No audio metadata found');
      return null;
    }
    
    // Verify the file exists
    if (!(await audioExists(metadata.storagePath))) {
      logger.warn({ sparkId, storagePath: metadata.storagePath }, 'Audio file missing');
      return null;
    }
    
    return metadata.publicUrl;
  }

  /**
   * Check if audio needs regeneration (content changed).
   */
  async needsRegeneration(sparkId: number): Promise<boolean> {
    const spark = await fetchSparkById(sparkId);
    if (!spark) return false;
    
    const currentHash = generateContentHash(spark);
    const metadata = await getAudioMetadata(sparkId);
    
    if (!metadata) return true;
    
    return metadata.contentHash !== currentHash;
  }

  /**
   * Get generation status for all sparks.
   */
  async getStatus(): Promise<{
    total: number;
    generated: number;
    pending: number;
    outdated: number;
    sparks: Array<{
      id: number;
      title: string;
      status: 'generated' | 'pending' | 'outdated';
      audioUrl?: string;
      generatedAt?: string;
    }>;
  }> {
    const allSparks = await fetchAllSparks();
    const sparkStatuses = [];
    
    let generated = 0;
    let pending = 0;
    let outdated = 0;
    
    for (const spark of allSparks) {
      const metadata = await getAudioMetadata(spark.id);
      const currentHash = generateContentHash(spark);
      
      let status: 'generated' | 'pending' | 'outdated';
      
      if (!metadata) {
        status = 'pending';
        pending++;
      } else if (metadata.contentHash !== currentHash) {
        status = 'outdated';
        outdated++;
      } else {
        status = 'generated';
        generated++;
      }
      
      sparkStatuses.push({
        id: spark.id,
        title: spark.title,
        status,
        audioUrl: metadata?.publicUrl,
        generatedAt: metadata?.generatedAt,
      });
    }
    
    return {
      total: allSparks.length,
      generated,
      pending,
      outdated,
      sparks: sparkStatuses,
    };
  }

  /**
   * Regenerate audio for sparks with outdated content.
   */
  async regenerateOutdated(): Promise<GenerationResult[]> {
    const allSparks = await fetchAllSparks();
    const results: GenerationResult[] = [];
    
    for (const spark of allSparks) {
      if (await this.needsRegeneration(spark.id)) {
        const result = await this.generateForSpark(spark.id, { force: true });
        results.push(result);
        
        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    return results;
  }
}

// Export singleton instance
export const sparkAudioService = new SparkAudioService();