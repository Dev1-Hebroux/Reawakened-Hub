/**
 * Background Job Scheduler
 * 
 * Manages scheduled tasks for notifications, cleanup, and maintenance.
 * Uses node-cron for scheduling with error handling and logging.
 */

import cron from 'node-cron';
import { NotificationService } from '../services/notificationService';
import { logger } from '../lib/logger';

const notificationService = new NotificationService();

interface ScheduledJob {
  name: string;
  schedule: string;
  handler: () => Promise<void>;
  enabled: boolean;
}

// ============================================================================
// Job Definitions
// ============================================================================

const jobs: ScheduledJob[] = [
  {
    name: 'process-scheduled-notifications',
    schedule: '* * * * *', // Every minute
    enabled: true,
    handler: async () => {
      const processed = await notificationService.processScheduledNotifications();
      if (processed > 0) {
        logger.info({ processed }, 'Processed scheduled notifications');
      }
    },
  },
  {
    name: 'send-streak-reminders',
    schedule: '0 8 * * *', // 8 AM daily
    enabled: true,
    handler: async () => {
      const sent = await notificationService.sendStreakReminders();
      logger.info({ sent }, 'Sent streak reminder notifications');
    },
  },
  {
    name: 'send-streak-at-risk-alerts',
    schedule: '0 20 * * *', // 8 PM daily
    enabled: true,
    handler: async () => {
      const sent = await notificationService.sendStreakAtRiskNotifications();
      logger.info({ sent }, 'Sent streak-at-risk notifications');
    },
  },
  {
    name: 'send-lab-reminders',
    schedule: '*/5 * * * *', // Every 5 minutes
    enabled: true,
    handler: async () => {
      const sent = await notificationService.sendLabReminders();
      if (sent > 0) {
        logger.info({ sent }, 'Sent lab reminder notifications');
      }
    },
  },
  {
    name: 'cleanup-old-notifications',
    schedule: '0 3 * * 0', // 3 AM every Sunday
    enabled: true,
    handler: async () => {
      const deleted = await cleanupOldNotifications(90); // 90 days
      logger.info({ deleted }, 'Cleaned up old notifications');
    },
  },
  {
    name: 'cleanup-expired-sessions',
    schedule: '0 4 * * *', // 4 AM daily
    enabled: true,
    handler: async () => {
      const deleted = await cleanupExpiredSessions();
      logger.info({ deleted }, 'Cleaned up expired sessions');
    },
  },
];

// ============================================================================
// Cleanup Functions
// ============================================================================

async function cleanupOldNotifications(daysOld: number): Promise<number> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysOld);

  // Implementation would use your ORM
  // const result = await db.delete(notifications)
  //   .where(and(
  //     eq(notifications.isRead, true),
  //     lte(notifications.createdAt, cutoffDate)
  //   ));
  // return result.rowCount || 0;
  
  return 0; // Placeholder
}

async function cleanupExpiredSessions(): Promise<number> {
  // Implementation would clean up expired sessions from your session store
  return 0; // Placeholder
}

// ============================================================================
// Scheduler Class
// ============================================================================

class JobScheduler {
  private scheduledJobs: Map<string, cron.ScheduledTask> = new Map();
  private isRunning = false;

  /**
   * Start all scheduled jobs.
   */
  start(): void {
    if (this.isRunning) {
      logger.warn('Job scheduler is already running');
      return;
    }

    logger.info('Starting job scheduler...');

    for (const job of jobs) {
      if (!job.enabled) {
        logger.info({ jobName: job.name }, 'Skipping disabled job');
        continue;
      }

      if (!cron.validate(job.schedule)) {
        logger.error({ jobName: job.name, schedule: job.schedule }, 'Invalid cron schedule');
        continue;
      }

      const task = cron.schedule(job.schedule, async () => {
        await this.runJob(job);
      });

      this.scheduledJobs.set(job.name, task);
      logger.info({ jobName: job.name, schedule: job.schedule }, 'Scheduled job');
    }

    this.isRunning = true;
    logger.info({ jobCount: this.scheduledJobs.size }, 'Job scheduler started');
  }

  /**
   * Stop all scheduled jobs.
   */
  stop(): void {
    if (!this.isRunning) {
      return;
    }

    logger.info('Stopping job scheduler...');

    for (const [name, task] of this.scheduledJobs) {
      task.stop();
      logger.info({ jobName: name }, 'Stopped job');
    }

    this.scheduledJobs.clear();
    this.isRunning = false;
    logger.info('Job scheduler stopped');
  }

  /**
   * Run a specific job immediately.
   */
  async runJobNow(jobName: string): Promise<void> {
    const job = jobs.find(j => j.name === jobName);
    
    if (!job) {
      throw new Error(`Job not found: ${jobName}`);
    }

    await this.runJob(job);
  }

  /**
   * Get status of all jobs.
   */
  getStatus(): Array<{ name: string; enabled: boolean; scheduled: boolean }> {
    return jobs.map(job => ({
      name: job.name,
      enabled: job.enabled,
      scheduled: this.scheduledJobs.has(job.name),
    }));
  }

  /**
   * Internal job runner with error handling.
   */
  private async runJob(job: ScheduledJob): Promise<void> {
    const startTime = Date.now();
    const jobLogger = logger.child({ jobName: job.name });

    jobLogger.info('Job started');

    try {
      await job.handler();
      
      const duration = Date.now() - startTime;
      jobLogger.info({ durationMs: duration }, 'Job completed successfully');
    } catch (error) {
      const duration = Date.now() - startTime;
      jobLogger.error({ 
        err: error, 
        durationMs: duration 
      }, 'Job failed');

      // Could send alert here for critical job failures
    }
  }
}

// ============================================================================
// Singleton Export
// ============================================================================

export const jobScheduler = new JobScheduler();

/**
 * Initialize the job scheduler.
 * Call this from your server startup.
 */
export function initializeJobScheduler(): void {
  // Only run in production or if explicitly enabled
  const shouldRun = process.env.NODE_ENV === 'production' || 
                    process.env.ENABLE_JOBS === 'true';

  if (shouldRun) {
    jobScheduler.start();
  } else {
    logger.info('Job scheduler disabled in non-production environment');
  }
}

/**
 * Gracefully shutdown the job scheduler.
 * Call this on server shutdown.
 */
export function shutdownJobScheduler(): void {
  jobScheduler.stop();
}