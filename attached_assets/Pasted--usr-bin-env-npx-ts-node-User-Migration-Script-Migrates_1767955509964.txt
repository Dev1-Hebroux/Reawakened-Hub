#!/usr/bin/env npx ts-node
/**
 * User Migration Script
 * 
 * Migrates existing Replit users to the new dual-auth system.
 * Sends emails to users allowing them to set a password.
 * 
 * Usage:
 *   npx ts-node scripts/migrate-users.ts analyze      - Show migration status
 *   npx ts-node scripts/migrate-users.ts prepare      - Add database columns
 *   npx ts-node scripts/migrate-users.ts dry-run      - Preview migration
 *   npx ts-node scripts/migrate-users.ts migrate      - Send migration emails
 */

import { config } from 'dotenv';
config();

import { db } from '../server/db';
import { users } from '@shared/schema';
import { eq, isNull, sql } from 'drizzle-orm';
import { generateToken } from '../server/services/authService';
import { sendMigrationEmail } from '../server/services/emailService';

// Colors for terminal output
const c = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
};

function log(msg: string, color = c.reset) {
  console.log(`${color}${msg}${c.reset}`);
}

function header(msg: string) {
  console.log();
  log('═'.repeat(60), c.cyan);
  log(`  ${msg}`, c.bright);
  log('═'.repeat(60), c.cyan);
  console.log();
}

interface MigrationUser {
  id: number;
  email: string;
  firstName: string | null;
  replitId: string | null;
  authProvider: string | null;
  hasPassword: boolean;
}

async function getUsers(): Promise<MigrationUser[]> {
  const result = await db
    .select({
      id: users.id,
      email: users.email,
      firstName: users.firstName,
      replitId: users.replitId,
      authProvider: users.authProvider,
      passwordHash: users.passwordHash,
    })
    .from(users)
    .orderBy(users.id);
  
  return result.map(u => ({
    id: u.id,
    email: u.email,
    firstName: u.firstName,
    replitId: u.replitId,
    authProvider: u.authProvider,
    hasPassword: !!u.passwordHash,
  }));
}

// ============================================================================
// Commands
// ============================================================================

async function analyze() {
  header('User Migration Analysis');
  
  const allUsers = await getUsers();
  
  const stats = {
    total: allUsers.length,
    withPassword: allUsers.filter(u => u.hasPassword).length,
    needsMigration: allUsers.filter(u => !u.hasPassword && u.replitId).length,
    replitOnly: allUsers.filter(u => u.authProvider === 'replit').length,
    emailOnly: allUsers.filter(u => u.authProvider === 'email').length,
    both: allUsers.filter(u => u.authProvider === 'both').length,
  };
  
  log(`Total Users:        ${stats.total}`);
  log(`With Password:      ${stats.withPassword}`, c.green);
  log(`Replit Only:        ${stats.replitOnly}`, c.yellow);
  log(`Email Only:         ${stats.emailOnly}`, c.cyan);
  log(`Both Methods:       ${stats.both}`, c.green);
  log(`Needs Migration:    ${stats.needsMigration}`, c.yellow);
  
  if (stats.needsMigration > 0) {
    console.log();
    log('Users requiring migration:', c.bright);
    const needsMigration = allUsers.filter(u => !u.hasPassword && u.replitId);
    for (const user of needsMigration.slice(0, 10)) {
      log(`  [${user.id}] ${user.email}`, c.gray);
    }
    if (needsMigration.length > 10) {
      log(`  ... and ${needsMigration.length - 10} more`, c.gray);
    }
  } else {
    log('✓ All users have passwords or email auth.', c.green);
  }
}

async function prepare() {
  header('Preparing Database');
  
  log('Adding auth columns to users table...');
  
  try {
    await db.execute(sql`
      ALTER TABLE users 
      ADD COLUMN IF NOT EXISTS password_hash TEXT,
      ADD COLUMN IF NOT EXISTS auth_provider VARCHAR(20) DEFAULT 'replit',
      ADD COLUMN IF NOT EXISTS email_verified_at TIMESTAMP,
      ADD COLUMN IF NOT EXISTS last_login_at TIMESTAMP,
      ADD COLUMN IF NOT EXISTS login_attempts INTEGER DEFAULT 0,
      ADD COLUMN IF NOT EXISTS locked_until TIMESTAMP,
      ADD COLUMN IF NOT EXISTS is_disabled BOOLEAN DEFAULT FALSE
    `);
    log('✓ Columns added to users table', c.green);
  } catch (error) {
    log(`Error: ${error}`, c.red);
  }
  
  log('Creating sessions table...');
  try {
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS user_sessions (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        token TEXT NOT NULL UNIQUE,
        expires_at TIMESTAMP NOT NULL,
        user_agent TEXT,
        ip_address VARCHAR(45),
        device_name VARCHAR(100),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        last_activity_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);
    log('✓ Sessions table created', c.green);
  } catch (error) {
    log(`Error: ${error}`, c.red);
  }
  
  log('Creating password reset tokens table...');
  try {
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS password_reset_tokens (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        token TEXT NOT NULL UNIQUE,
        expires_at TIMESTAMP NOT NULL,
        used_at TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);
    log('✓ Password reset tokens table created', c.green);
  } catch (error) {
    log(`Error: ${error}`, c.red);
  }
  
  log('Creating email verification tokens table...');
  try {
    await db.execute(sql`
      CREATE TABLE IF NOT EXISTS email_verification_tokens (
        id SERIAL PRIMARY KEY,
        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        email VARCHAR(255) NOT NULL,
        token TEXT NOT NULL UNIQUE,
        expires_at TIMESTAMP NOT NULL,
        verified_at TIMESTAMP,
        created_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);
    log('✓ Email verification tokens table created', c.green);
  } catch (error) {
    log(`Error: ${error}`, c.red);
  }
  
  log('Updating existing users auth_provider...');
  try {
    await db.execute(sql`
      UPDATE users 
      SET auth_provider = 'replit' 
      WHERE auth_provider IS NULL AND replit_id IS NOT NULL
    `);
    log('✓ Existing users updated', c.green);
  } catch (error) {
    log(`Error: ${error}`, c.red);
  }
  
  console.log();
  log('✓ Database preparation complete!', c.green);
}

async function migrate(dryRun: boolean = false) {
  header(dryRun ? 'Migration Dry Run' : 'User Migration');
  
  const allUsers = await getUsers();
  const needsMigration = allUsers.filter(u => !u.hasPassword && u.replitId);
  
  if (needsMigration.length === 0) {
    log('✓ No users need migration.', c.green);
    return;
  }
  
  log(`Found ${needsMigration.length} users to migrate`);
  console.log();
  
  let migrated = 0;
  let failed = 0;
  const errors: string[] = [];
  
  for (const user of needsMigration) {
    try {
      if (dryRun) {
        log(`  Would migrate: ${user.email}`, c.gray);
        migrated++;
        continue;
      }
      
      // Generate password reset token (7 day expiry for migration)
      const token = generateToken(32);
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
      
      await db.execute(sql`
        INSERT INTO password_reset_tokens (user_id, token, expires_at)
        VALUES (${user.id}, ${token}, ${expiresAt})
        ON CONFLICT (user_id) DO UPDATE SET token = ${token}, expires_at = ${expiresAt}
      `);
      
      // Send migration email
      await sendMigrationEmail(user.email, user.firstName, token);
      
      log(`  ✓ Migrated: ${user.email}`, c.green);
      migrated++;
      
      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
      
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      errors.push(`${user.email}: ${errorMsg}`);
      log(`  ✗ Failed: ${user.email}`, c.red);
      failed++;
    }
  }
  
  console.log();
  header('Migration Summary');
  log(`Migrated: ${migrated}`, c.green);
  log(`Failed:   ${failed}`, c.red);
  
  if (errors.length > 0) {
    console.log();
    log('Errors:', c.red);
    errors.forEach(e => log(`  ${e}`, c.gray));
  }
}

function showHelp() {
  log(`
${c.bright}User Migration Script${c.reset}

Migrates existing Replit users to the new dual-auth system.

${c.cyan}Usage:${c.reset}
  npx ts-node scripts/migrate-users.ts [command]

${c.cyan}Commands:${c.reset}
  analyze     Show migration status and user counts
  prepare     Add necessary database columns and tables
  dry-run     Preview migration without making changes
  migrate     Send migration emails to users
  help        Show this help message

${c.cyan}Process:${c.reset}
  1. Run 'analyze' to see how many users need migration
  2. Run 'prepare' to set up the database
  3. Run 'dry-run' to preview the migration
  4. Run 'migrate' to send password setup emails

${c.cyan}Notes:${c.reset}
  - Users will receive an email to set their password
  - Links expire in 7 days
  - Users can still sign in with Replit during migration
`);
}

// Main
async function main() {
  const command = process.argv[2] || 'help';
  
  try {
    switch (command) {
      case 'analyze': await analyze(); break;
      case 'prepare': await prepare(); break;
      case 'dry-run': await migrate(true); break;
      case 'migrate': await migrate(false); break;
      case 'help':
      default: showHelp(); break;
    }
  } catch (error) {
    log(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, c.red);
    process.exit(1);
  }
}

main();