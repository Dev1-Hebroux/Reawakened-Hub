/**
 * Combined Init Endpoint
 * 
 * Instead of making multiple API calls on page load:
 * - /api/auth/csrf
 * - /api/auth/me
 * - /api/notifications/unread-count
 * - /api/user/preferences
 * 
 * Use a single /api/init endpoint that returns everything needed.
 * 
 * This reduces:
 * - Network round trips
 * - Database queries
 * - Time to interactive
 */

import { Router } from 'express';
import { loadUser, generateCsrfToken } from '../middleware/auth';
import { db } from '../db';
import { sql } from 'drizzle-orm';

const router = Router();

/**
 * GET /api/init
 * 
 * Returns all data needed for initial page load in a single request.
 * This should be the FIRST API call made by the client.
 */
router.get('/init', loadUser, async (req, res) => {
  const startTime = Date.now();
  
  try {
    // Generate CSRF token
    const csrfToken = generateCsrfToken(res);
    
    // If not authenticated, return minimal response
    if (!req.user) {
      return res.json({
        authenticated: false,
        user: null,
        csrfToken,
        notifications: { unread: 0 },
        preferences: null,
        serverTime: new Date().toISOString(),
        loadTime: Date.now() - startTime,
      });
    }
    
    // Fetch everything in parallel for authenticated users
    const [notifications, preferences, streakData] = await Promise.all([
      getUnreadNotificationCount(req.user.id),
      getUserPreferences(req.user.id),
      getCurrentStreak(req.user.id),
    ]);
    
    res.json({
      authenticated: true,
      user: {
        id: req.user.id,
        email: req.user.email,
        firstName: req.user.firstName,
        lastName: req.user.lastName,
        role: req.user.role,
        emailVerified: req.user.emailVerified,
        authProvider: req.user.authProvider,
      },
      csrfToken,
      notifications: {
        unread: notifications,
      },
      preferences,
      streak: streakData,
      serverTime: new Date().toISOString(),
      loadTime: Date.now() - startTime,
    });
  } catch (error) {
    console.error('Error in /api/init:', error);
    
    // Return minimal response on error
    res.json({
      authenticated: !!req.user,
      user: req.user || null,
      csrfToken: generateCsrfToken(res),
      notifications: { unread: 0 },
      preferences: null,
      serverTime: new Date().toISOString(),
      error: 'Failed to load some data',
    });
  }
});

// ============================================================================
// Helper Functions
// ============================================================================

async function getUnreadNotificationCount(userId: number): Promise<number> {
  try {
    const result = await db.execute(sql`
      SELECT COUNT(*) as count 
      FROM notifications 
      WHERE user_id = ${userId} 
        AND read_at IS NULL
    `);
    return Number(result.rows[0]?.count) || 0;
  } catch {
    return 0;
  }
}

async function getUserPreferences(userId: number): Promise<Record<string, any> | null> {
  try {
    const result = await db.execute(sql`
      SELECT 
        notification_email,
        notification_push,
        daily_reminder_time,
        timezone,
        theme,
        language
      FROM user_preferences 
      WHERE user_id = ${userId}
      LIMIT 1
    `);
    return result.rows[0] || null;
  } catch {
    return null;
  }
}

async function getCurrentStreak(userId: number): Promise<{ current: number; longest: number } | null> {
  try {
    const result = await db.execute(sql`
      SELECT current_streak, longest_streak
      FROM user_streaks 
      WHERE user_id = ${userId}
      LIMIT 1
    `);
    
    if (result.rows[0]) {
      return {
        current: Number(result.rows[0].current_streak) || 0,
        longest: Number(result.rows[0].longest_streak) || 0,
      };
    }
    return { current: 0, longest: 0 };
  } catch {
    return null;
  }
}

export const initRoutes = router;

// ============================================================================
// Client-side usage example
// ============================================================================

/*
// In your client app initialization:

interface InitData {
  authenticated: boolean;
  user: User | null;
  csrfToken: string;
  notifications: { unread: number };
  preferences: UserPreferences | null;
  streak: { current: number; longest: number } | null;
  serverTime: string;
}

async function initializeApp(): Promise<InitData> {
  const response = await fetch('/api/init', {
    credentials: 'include',
  });
  
  const data: InitData = await response.json();
  
  // Store CSRF token
  window.__CSRF_TOKEN__ = data.csrfToken;
  
  // Update auth state
  if (data.authenticated && data.user) {
    authStore.setUser(data.user);
  }
  
  // Update notification badge
  notificationStore.setUnreadCount(data.notifications.unread);
  
  // Set user preferences
  if (data.preferences) {
    preferencesStore.setPreferences(data.preferences);
  }
  
  return data;
}

// Call on app start
initializeApp().then(data => {
  console.log(`App initialized in ${data.loadTime}ms`);
});
*/