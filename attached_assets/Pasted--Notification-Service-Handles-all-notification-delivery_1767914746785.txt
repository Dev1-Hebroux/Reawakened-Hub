/**
 * Notification Service
 * 
 * Handles all notification delivery including:
 * - Push notifications
 * - Email digests
 * - In-app notifications
 * - Scheduled reminders
 */

import { db } from '../db';
import { eq, and, lte, isNull, desc, sql } from 'drizzle-orm';
import { logger } from '../lib/logger';
import type { NotificationType, NotificationSettings } from '@shared/types';

// ============================================================================
// Types
// ============================================================================

interface NotificationPayload {
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  data?: Record<string, unknown>;
  scheduledFor?: Date;
}

interface PushPayload {
  title: string;
  body: string;
  icon?: string;
  badge?: number;
  data?: Record<string, unknown>;
  actions?: Array<{ action: string; title: string }>;
}

interface EmailPayload {
  to: string;
  subject: string;
  template: string;
  data: Record<string, unknown>;
}

interface NotificationResult {
  success: boolean;
  notificationId?: number;
  channels: string[];
  errors?: string[];
}

// ============================================================================
// Notification Templates
// ============================================================================

const notificationTemplates: Record<NotificationType, {
  title: (data: Record<string, unknown>) => string;
  body: (data: Record<string, unknown>) => string;
  icon: string;
}> = {
  streak_reminder: {
    title: () => "Keep your streak alive! ðŸ”¥",
    body: (data) => `You haven't read today. Just ${data.minutesEstimate || 5} minutes to maintain your ${data.currentStreak}-day streak.`,
    icon: '/icons/streak.png',
  },
  streak_at_risk: {
    title: () => "Your streak is at risk! âš ï¸",
    body: (data) => `Your ${data.currentStreak}-day streak will end in ${data.hoursRemaining} hours. Open the app to keep it going.`,
    icon: '/icons/streak-warning.png',
  },
  streak_milestone: {
    title: (data) => `${data.milestone}-Day Streak! ðŸŽ‰`,
    body: (data) => `Amazing! You've maintained a ${data.milestone}-day streak. Keep up the great work!`,
    icon: '/icons/celebration.png',
  },
  daily_reading: {
    title: () => "Your daily reading is ready ðŸ“–",
    body: (data) => `Continue "${data.planTitle}" - Day ${data.dayNumber}`,
    icon: '/icons/reading.png',
  },
  journey_continue: {
    title: () => "Continue your journey",
    body: (data) => `Pick up where you left off in "${data.journeyTitle}"`,
    icon: '/icons/journey.png',
  },
  group_discussion: {
    title: () => "New in your group",
    body: (data) => `${data.authorName} posted in ${data.groupName}`,
    icon: '/icons/group.png',
  },
  group_lab_reminder: {
    title: () => "Group session starting soon",
    body: (data) => `"${data.labTitle}" starts in ${data.minutesUntil} minutes`,
    icon: '/icons/lab.png',
  },
  prayer_request: {
    title: () => "New prayer request",
    body: (data) => `${data.authorName} shared a prayer request in ${data.groupName}`,
    icon: '/icons/prayer.png',
  },
  accountability_checkin: {
    title: () => "Accountability check-in",
    body: (data) => `${data.partnerName} is checking in on your progress`,
    icon: '/icons/accountability.png',
  },
  goal_milestone: {
    title: () => "Goal milestone reached! ðŸŽ¯",
    body: (data) => `You've completed "${data.milestoneName}" for your goal "${data.goalTitle}"`,
    icon: '/icons/goal.png',
  },
  system: {
    title: (data) => data.title as string || "Notification",
    body: (data) => data.body as string || "",
    icon: '/icons/system.png',
  },
};

// ============================================================================
// Notification Service
// ============================================================================

export class NotificationService {
  
  /**
   * Send a notification to a user across appropriate channels.
   */
  async send(payload: NotificationPayload): Promise<NotificationResult> {
    const { userId, type, title, body, data, scheduledFor } = payload;
    const channels: string[] = [];
    const errors: string[] = [];
    
    try {
      // Get user preferences
      const preferences = await this.getUserNotificationPreferences(userId);
      
      // Store in-app notification
      const notificationId = await this.createInAppNotification({
        userId,
        type,
        title,
        body,
        data: data || {},
      });
      channels.push('in_app');
      
      // Send push notification if enabled
      if (preferences.pushEnabled && this.shouldSendPush(type, preferences)) {
        try {
          await this.sendPushNotification(userId, {
            title,
            body,
            icon: notificationTemplates[type]?.icon,
            data: { notificationId, type, ...data },
          });
          channels.push('push');
        } catch (error) {
          errors.push(`Push failed: ${(error as Error).message}`);
          logger.warn({ err: error, userId, type }, 'Push notification failed');
        }
      }
      
      logger.info({ userId, type, channels, notificationId }, 'Notification sent');
      
      return {
        success: true,
        notificationId,
        channels,
        errors: errors.length > 0 ? errors : undefined,
      };
    } catch (error) {
      logger.error({ err: error, userId, type }, 'Failed to send notification');
      return {
        success: false,
        channels,
        errors: [(error as Error).message],
      };
    }
  }
  
  /**
   * Send a templated notification.
   */
  async sendTemplated(
    userId: string,
    type: NotificationType,
    templateData: Record<string, unknown>
  ): Promise<NotificationResult> {
    const template = notificationTemplates[type];
    if (!template) {
      throw new Error(`Unknown notification type: ${type}`);
    }
    
    return this.send({
      userId,
      type,
      title: template.title(templateData),
      body: template.body(templateData),
      data: templateData,
    });
  }
  
  /**
   * Schedule a notification for later delivery.
   */
  async schedule(payload: NotificationPayload & { scheduledFor: Date }): Promise<number> {
    const { userId, type, title, body, data, scheduledFor } = payload;
    
    const [result] = await db.insert(scheduledNotifications).values({
      userId,
      type,
      title,
      body,
      data: data || {},
      scheduledFor,
      status: 'pending',
      createdAt: new Date(),
    }).returning({ id: scheduledNotifications.id });
    
    logger.info({ 
      userId, 
      type, 
      scheduledFor, 
      scheduledNotificationId: result.id 
    }, 'Notification scheduled');
    
    return result.id;
  }
  
  /**
   * Process scheduled notifications that are due.
   * Should be called by a cron job every minute.
   */
  async processScheduledNotifications(): Promise<number> {
    const now = new Date();
    let processed = 0;
    
    try {
      const dueNotifications = await db.select()
        .from(scheduledNotifications)
        .where(and(
          eq(scheduledNotifications.status, 'pending'),
          lte(scheduledNotifications.scheduledFor, now)
        ))
        .limit(100);
      
      for (const notification of dueNotifications) {
        try {
          await this.send({
            userId: notification.userId,
            type: notification.type as NotificationType,
            title: notification.title,
            body: notification.body,
            data: notification.data as Record<string, unknown>,
          });
          
          await db.update(scheduledNotifications)
            .set({ status: 'sent', sentAt: new Date() })
            .where(eq(scheduledNotifications.id, notification.id));
          
          processed++;
        } catch (error) {
          await db.update(scheduledNotifications)
            .set({ 
              status: 'failed', 
              error: (error as Error).message 
            })
            .where(eq(scheduledNotifications.id, notification.id));
          
          logger.error({ 
            err: error, 
            notificationId: notification.id 
          }, 'Failed to process scheduled notification');
        }
      }
      
      if (processed > 0) {
        logger.info({ processed }, 'Processed scheduled notifications');
      }
      
      return processed;
    } catch (error) {
      logger.error({ err: error }, 'Failed to process scheduled notifications batch');
      return 0;
    }
  }
  
  /**
   * Send daily streak reminders.
   * Should be called at the user's preferred reminder time.
   */
  async sendStreakReminders(): Promise<number> {
    let sent = 0;
    
    try {
      // Find users who haven't completed today's reading and have reminders enabled
      const usersNeedingReminder = await this.getUsersNeedingStreakReminder();
      
      for (const user of usersNeedingReminder) {
        const streakData = await this.getUserStreakData(user.id);
        
        if (streakData.currentStreak > 0 && !streakData.completedToday) {
          await this.sendTemplated(user.id, 'streak_reminder', {
            currentStreak: streakData.currentStreak,
            minutesEstimate: 5,
          });
          sent++;
        }
      }
      
      logger.info({ sent }, 'Sent streak reminders');
      return sent;
    } catch (error) {
      logger.error({ err: error }, 'Failed to send streak reminders');
      return 0;
    }
  }
  
  /**
   * Send streak-at-risk notifications.
   * Should be called in the evening for users who haven't read.
   */
  async sendStreakAtRiskNotifications(): Promise<number> {
    let sent = 0;
    
    try {
      const usersAtRisk = await this.getUsersWithStreakAtRisk();
      
      for (const user of usersAtRisk) {
        const hoursUntilMidnight = this.getHoursUntilMidnight(user.timezone);
        
        if (hoursUntilMidnight <= 4) {
          await this.sendTemplated(user.id, 'streak_at_risk', {
            currentStreak: user.currentStreak,
            hoursRemaining: hoursUntilMidnight,
          });
          sent++;
        }
      }
      
      logger.info({ sent }, 'Sent streak-at-risk notifications');
      return sent;
    } catch (error) {
      logger.error({ err: error }, 'Failed to send streak-at-risk notifications');
      return 0;
    }
  }
  
  /**
   * Send streak milestone notifications.
   */
  async sendStreakMilestone(userId: string, milestone: number): Promise<void> {
    const milestones = [7, 14, 21, 30, 60, 90, 100, 180, 365];
    
    if (milestones.includes(milestone)) {
      await this.sendTemplated(userId, 'streak_milestone', { milestone });
    }
  }
  
  /**
   * Send group lab reminders.
   */
  async sendLabReminders(): Promise<number> {
    let sent = 0;
    
    try {
      const upcomingLabs = await this.getUpcomingLabs(30); // 30 minutes before
      
      for (const lab of upcomingLabs) {
        const participants = await this.getLabParticipants(lab.id);
        
        for (const participant of participants) {
          await this.sendTemplated(participant.userId, 'group_lab_reminder', {
            labTitle: lab.title,
            groupName: lab.groupName,
            minutesUntil: 30,
          });
          sent++;
        }
      }
      
      logger.info({ sent }, 'Sent lab reminders');
      return sent;
    } catch (error) {
      logger.error({ err: error }, 'Failed to send lab reminders');
      return 0;
    }
  }
  
  /**
   * Mark notification as read.
   */
  async markAsRead(userId: string, notificationId: number): Promise<void> {
    await db.update(notifications)
      .set({ isRead: true, readAt: new Date() })
      .where(and(
        eq(notifications.id, notificationId),
        eq(notifications.userId, userId)
      ));
  }
  
  /**
   * Mark all notifications as read for a user.
   */
  async markAllAsRead(userId: string): Promise<number> {
    const result = await db.update(notifications)
      .set({ isRead: true, readAt: new Date() })
      .where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, false)
      ));
    
    return result.rowCount || 0;
  }
  
  /**
   * Get unread notification count.
   */
  async getUnreadCount(userId: string): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` })
      .from(notifications)
      .where(and(
        eq(notifications.userId, userId),
        eq(notifications.isRead, false)
      ));
    
    return Number(result[0]?.count || 0);
  }
  
  /**
   * Get user notifications with pagination.
   */
  async getUserNotifications(
    userId: string,
    options: { limit?: number; offset?: number; unreadOnly?: boolean }
  ): Promise<{ notifications: any[]; total: number; unread: number }> {
    const { limit = 20, offset = 0, unreadOnly = false } = options;
    
    const conditions = [eq(notifications.userId, userId)];
    if (unreadOnly) {
      conditions.push(eq(notifications.isRead, false));
    }
    
    const [items, countResult, unreadResult] = await Promise.all([
      db.select()
        .from(notifications)
        .where(and(...conditions))
        .orderBy(desc(notifications.createdAt))
        .limit(limit)
        .offset(offset),
      db.select({ count: sql<number>`count(*)` })
        .from(notifications)
        .where(and(...conditions)),
      db.select({ count: sql<number>`count(*)` })
        .from(notifications)
        .where(and(
          eq(notifications.userId, userId),
          eq(notifications.isRead, false)
        )),
    ]);
    
    return {
      notifications: items,
      total: Number(countResult[0]?.count || 0),
      unread: Number(unreadResult[0]?.count || 0),
    };
  }
  
  // ============================================================================
  // Private Helper Methods
  // ============================================================================
  
  private async getUserNotificationPreferences(userId: string): Promise<NotificationSettings> {
    // Fetch from user preferences table
    // Return defaults if not set
    return {
      dailyReminders: true,
      dailyReminderTime: '08:00',
      streakAlerts: true,
      groupNotifications: true,
      emailDigest: 'weekly',
      pushEnabled: true,
    };
  }
  
  private shouldSendPush(type: NotificationType, preferences: NotificationSettings): boolean {
    switch (type) {
      case 'streak_reminder':
      case 'streak_at_risk':
      case 'streak_milestone':
        return preferences.streakAlerts;
      case 'group_discussion':
      case 'group_lab_reminder':
      case 'prayer_request':
        return preferences.groupNotifications;
      default:
        return true;
    }
  }
  
  private async createInAppNotification(data: {
    userId: string;
    type: NotificationType;
    title: string;
    body: string;
    data: Record<string, unknown>;
  }): Promise<number> {
    const [result] = await db.insert(notifications).values({
      ...data,
      isRead: false,
      createdAt: new Date(),
    }).returning({ id: notifications.id });
    
    return result.id;
  }
  
  private async sendPushNotification(userId: string, payload: PushPayload): Promise<void> {
    // Implementation would use web-push or Firebase Cloud Messaging
    // For now, this is a placeholder
    logger.debug({ userId, payload }, 'Would send push notification');
  }
  
  private async getUsersNeedingStreakReminder(): Promise<{ id: string }[]> {
    // Query users who have reminders enabled and haven't read today
    return [];
  }
  
  private async getUserStreakData(userId: string): Promise<{
    currentStreak: number;
    completedToday: boolean;
  }> {
    return { currentStreak: 0, completedToday: false };
  }
  
  private async getUsersWithStreakAtRisk(): Promise<{
    id: string;
    currentStreak: number;
    timezone: string;
  }[]> {
    return [];
  }
  
  private getHoursUntilMidnight(timezone: string): number {
    // Calculate hours until midnight in user's timezone
    return 4;
  }
  
  private async getUpcomingLabs(minutesBefore: number): Promise<{
    id: number;
    title: string;
    groupName: string;
  }[]> {
    return [];
  }
  
  private async getLabParticipants(labId: number): Promise<{ userId: string }[]> {
    return [];
  }
}

// Placeholder table references (would be imported from schema)
const notifications: any = {};
const scheduledNotifications: any = {};

// Export singleton instance
export const notificationService = new NotificationService();