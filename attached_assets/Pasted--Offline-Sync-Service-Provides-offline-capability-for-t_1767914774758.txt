/**
 * Offline Sync Service
 * 
 * Provides offline capability for the platform including:
 * - Service worker registration and management
 * - IndexedDB storage for offline data
 * - Background sync for pending operations
 * - Conflict resolution for synced data
 */

// ============================================================================
// Types
// ============================================================================

interface SyncQueueItem {
  id: string;
  operation: 'create' | 'update' | 'delete';
  endpoint: string;
  method: string;
  body?: unknown;
  timestamp: number;
  retryCount: number;
  maxRetries: number;
}

interface CachedContent {
  key: string;
  data: unknown;
  timestamp: number;
  expiresAt: number;
  version: number;
}

interface SyncStatus {
  isOnline: boolean;
  pendingOperations: number;
  lastSyncAt: Date | null;
  syncInProgress: boolean;
}

// ============================================================================
// IndexedDB Configuration
// ============================================================================

const DB_NAME = 'reawakened_offline';
const DB_VERSION = 1;

const STORES = {
  READING_PLANS: 'reading_plans',
  READING_PLAN_DAYS: 'reading_plan_days',
  JOURNEYS: 'journeys',
  JOURNEY_DAYS: 'journey_days',
  SPARKS: 'sparks',
  USER_PROGRESS: 'user_progress',
  JOURNAL_ENTRIES: 'journal_entries',
  SYNC_QUEUE: 'sync_queue',
  CACHE_META: 'cache_meta',
} as const;

// ============================================================================
// Offline Service
// ============================================================================

export class OfflineService {
  private db: IDBDatabase | null = null;
  private syncStatus: SyncStatus = {
    isOnline: typeof navigator !== 'undefined' ? navigator.onLine : true,
    pendingOperations: 0,
    lastSyncAt: null,
    syncInProgress: false,
  };
  private listeners: Set<(status: SyncStatus) => void> = new Set();
  
  /**
   * Initialize the offline service.
   */
  async initialize(): Promise<void> {
    if (typeof window === 'undefined') return;
    
    // Open IndexedDB
    this.db = await this.openDatabase();
    
    // Set up online/offline listeners
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
    
    // Register service worker
    await this.registerServiceWorker();
    
    // Update pending operations count
    await this.updatePendingCount();
    
    // Attempt initial sync if online
    if (this.syncStatus.isOnline) {
      this.sync();
    }
  }
  
  /**
   * Clean up listeners.
   */
  destroy(): void {
    if (typeof window === 'undefined') return;
    
    window.removeEventListener('online', this.handleOnline);
    window.removeEventListener('offline', this.handleOffline);
    
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
  
  // ============================================================================
  // Database Operations
  // ============================================================================
  
  private openDatabase(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object stores
        if (!db.objectStoreNames.contains(STORES.READING_PLANS)) {
          db.createObjectStore(STORES.READING_PLANS, { keyPath: 'id' });
        }
        
        if (!db.objectStoreNames.contains(STORES.READING_PLAN_DAYS)) {
          const store = db.createObjectStore(STORES.READING_PLAN_DAYS, { keyPath: 'id' });
          store.createIndex('planId', 'planId', { unique: false });
        }
        
        if (!db.objectStoreNames.contains(STORES.JOURNEYS)) {
          db.createObjectStore(STORES.JOURNEYS, { keyPath: 'id' });
        }
        
        if (!db.objectStoreNames.contains(STORES.JOURNEY_DAYS)) {
          const store = db.createObjectStore(STORES.JOURNEY_DAYS, { keyPath: 'id' });
          store.createIndex('journeyId', 'journeyId', { unique: false });
        }
        
        if (!db.objectStoreNames.contains(STORES.SPARKS)) {
          db.createObjectStore(STORES.SPARKS, { keyPath: 'id' });
        }
        
        if (!db.objectStoreNames.contains(STORES.USER_PROGRESS)) {
          const store = db.createObjectStore(STORES.USER_PROGRESS, { keyPath: 'id' });
          store.createIndex('type', 'type', { unique: false });
        }
        
        if (!db.objectStoreNames.contains(STORES.JOURNAL_ENTRIES)) {
          const store = db.createObjectStore(STORES.JOURNAL_ENTRIES, { keyPath: 'id' });
          store.createIndex('contextType', 'contextType', { unique: false });
          store.createIndex('syncStatus', 'syncStatus', { unique: false });
        }
        
        if (!db.objectStoreNames.contains(STORES.SYNC_QUEUE)) {
          const store = db.createObjectStore(STORES.SYNC_QUEUE, { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
        
        if (!db.objectStoreNames.contains(STORES.CACHE_META)) {
          db.createObjectStore(STORES.CACHE_META, { keyPath: 'key' });
        }
      };
    });
  }
  
  private async getStore(storeName: string, mode: IDBTransactionMode = 'readonly'): Promise<IDBObjectStore> {
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    const transaction = this.db.transaction(storeName, mode);
    return transaction.objectStore(storeName);
  }
  
  private async dbGet<T>(storeName: string, key: IDBValidKey): Promise<T | undefined> {
    const store = await this.getStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result as T | undefined);
    });
  }
  
  private async dbGetAll<T>(storeName: string): Promise<T[]> {
    const store = await this.getStore(storeName);
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result as T[]);
    });
  }
  
  private async dbPut<T>(storeName: string, value: T): Promise<void> {
    const store = await this.getStore(storeName, 'readwrite');
    return new Promise((resolve, reject) => {
      const request = store.put(value);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
  
  private async dbDelete(storeName: string, key: IDBValidKey): Promise<void> {
    const store = await this.getStore(storeName, 'readwrite');
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
  
  // ============================================================================
  // Content Caching
  // ============================================================================
  
  /**
   * Cache a reading plan and its days for offline access.
   */
  async cacheReadingPlan(planId: number): Promise<void> {
    try {
      const response = await fetch(`/api/reading-plans/${planId}/full`);
      if (!response.ok) throw new Error('Failed to fetch plan');
      
      const { plan, days } = await response.json();
      
      // Store plan
      await this.dbPut(STORES.READING_PLANS, {
        ...plan,
        cachedAt: Date.now(),
      });
      
      // Store days
      for (const day of days) {
        await this.dbPut(STORES.READING_PLAN_DAYS, {
          ...day,
          planId,
          cachedAt: Date.now(),
        });
      }
      
      // Update cache metadata
      await this.dbPut(STORES.CACHE_META, {
        key: `reading_plan_${planId}`,
        cachedAt: Date.now(),
        expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days
      });
      
      console.log(`Cached reading plan ${planId} for offline access`);
    } catch (error) {
      console.error('Failed to cache reading plan:', error);
      throw error;
    }
  }
  
  /**
   * Cache a journey and its days for offline access.
   */
  async cacheJourney(journeyId: number): Promise<void> {
    try {
      const response = await fetch(`/api/journeys/${journeyId}/full`);
      if (!response.ok) throw new Error('Failed to fetch journey');
      
      const { journey, days } = await response.json();
      
      await this.dbPut(STORES.JOURNEYS, {
        ...journey,
        cachedAt: Date.now(),
      });
      
      for (const day of days) {
        await this.dbPut(STORES.JOURNEY_DAYS, {
          ...day,
          journeyId,
          cachedAt: Date.now(),
        });
      }
      
      await this.dbPut(STORES.CACHE_META, {
        key: `journey_${journeyId}`,
        cachedAt: Date.now(),
        expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000,
      });
      
      console.log(`Cached journey ${journeyId} for offline access`);
    } catch (error) {
      console.error('Failed to cache journey:', error);
      throw error;
    }
  }
  
  /**
   * Get cached reading plan.
   */
  async getCachedReadingPlan(planId: number): Promise<{
    plan: unknown;
    days: unknown[];
  } | null> {
    const plan = await this.dbGet(STORES.READING_PLANS, planId);
    if (!plan) return null;
    
    const allDays = await this.dbGetAll<any>(STORES.READING_PLAN_DAYS);
    const days = allDays.filter(d => d.planId === planId);
    
    return { plan, days };
  }
  
  /**
   * Get cached journey.
   */
  async getCachedJourney(journeyId: number): Promise<{
    journey: unknown;
    days: unknown[];
  } | null> {
    const journey = await this.dbGet(STORES.JOURNEYS, journeyId);
    if (!journey) return null;
    
    const allDays = await this.dbGetAll<any>(STORES.JOURNEY_DAYS);
    const days = allDays.filter(d => d.journeyId === journeyId);
    
    return { journey, days };
  }
  
  /**
   * Cache today's spark.
   */
  async cacheDailySpark(spark: unknown): Promise<void> {
    await this.dbPut(STORES.SPARKS, {
      ...(spark as object),
      cachedAt: Date.now(),
      isDaily: true,
    });
  }
  
  // ============================================================================
  // Offline Operations Queue
  // ============================================================================
  
  /**
   * Queue an operation for later sync.
   */
  async queueOperation(operation: Omit<SyncQueueItem, 'id' | 'timestamp' | 'retryCount'>): Promise<string> {
    const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const item: SyncQueueItem = {
      ...operation,
      id,
      timestamp: Date.now(),
      retryCount: 0,
      maxRetries: operation.maxRetries || 3,
    };
    
    await this.dbPut(STORES.SYNC_QUEUE, item);
    await this.updatePendingCount();
    this.notifyListeners();
    
    // If online, attempt immediate sync
    if (this.syncStatus.isOnline && !this.syncStatus.syncInProgress) {
      this.sync();
    }
    
    return id;
  }
  
  /**
   * Save a journal entry offline.
   */
  async saveJournalEntryOffline(entry: {
    id?: number;
    content: string;
    contextType: string;
    contextId?: number;
  }): Promise<string> {
    const localId = entry.id?.toString() || `local_${Date.now()}`;
    
    await this.dbPut(STORES.JOURNAL_ENTRIES, {
      ...entry,
      id: localId,
      syncStatus: 'pending',
      localUpdatedAt: Date.now(),
    });
    
    // Queue sync operation
    return this.queueOperation({
      operation: entry.id ? 'update' : 'create',
      endpoint: entry.id ? `/api/journal-entries/${entry.id}` : '/api/journal-entries',
      method: entry.id ? 'PATCH' : 'POST',
      body: entry,
      maxRetries: 5,
    });
  }
  
  /**
   * Mark a day as complete offline.
   */
  async completeReadingPlanDayOffline(planId: number, dayNumber: number): Promise<string> {
    const progressId = `reading_${planId}_${dayNumber}`;
    
    await this.dbPut(STORES.USER_PROGRESS, {
      id: progressId,
      type: 'reading_plan',
      planId,
      dayNumber,
      completedAt: new Date().toISOString(),
      syncStatus: 'pending',
    });
    
    return this.queueOperation({
      operation: 'create',
      endpoint: `/api/user-reading-progress/${planId}/complete`,
      method: 'POST',
      body: { dayNumber, idempotencyKey: progressId },
      maxRetries: 5,
    });
  }
  
  // ============================================================================
  // Sync Operations
  // ============================================================================
  
  /**
   * Sync all pending operations.
   */
  async sync(): Promise<{ synced: number; failed: number }> {
    if (this.syncStatus.syncInProgress || !this.syncStatus.isOnline) {
      return { synced: 0, failed: 0 };
    }
    
    this.syncStatus.syncInProgress = true;
    this.notifyListeners();
    
    let synced = 0;
    let failed = 0;
    
    try {
      const queue = await this.dbGetAll<SyncQueueItem>(STORES.SYNC_QUEUE);
      const sortedQueue = queue.sort((a, b) => a.timestamp - b.timestamp);
      
      for (const item of sortedQueue) {
        try {
          await this.processQueueItem(item);
          await this.dbDelete(STORES.SYNC_QUEUE, item.id);
          synced++;
        } catch (error) {
          item.retryCount++;
          
          if (item.retryCount >= item.maxRetries) {
            console.error(`Max retries reached for operation ${item.id}`, error);
            await this.dbDelete(STORES.SYNC_QUEUE, item.id);
            failed++;
          } else {
            await this.dbPut(STORES.SYNC_QUEUE, item);
          }
        }
      }
      
      this.syncStatus.lastSyncAt = new Date();
    } finally {
      this.syncStatus.syncInProgress = false;
      await this.updatePendingCount();
      this.notifyListeners();
    }
    
    return { synced, failed };
  }
  
  private async processQueueItem(item: SyncQueueItem): Promise<void> {
    const response = await fetch(item.endpoint, {
      method: item.method,
      headers: {
        'Content-Type': 'application/json',
      },
      body: item.body ? JSON.stringify(item.body) : undefined,
      credentials: 'include',
    });
    
    if (!response.ok) {
      throw new Error(`Sync failed: ${response.status}`);
    }
  }
  
  // ============================================================================
  // Service Worker
  // ============================================================================
  
  private async registerServiceWorker(): Promise<void> {
    if (!('serviceWorker' in navigator)) return;
    
    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/',
      });
      
      console.log('Service Worker registered:', registration.scope);
      
      // Request background sync permission
      if ('sync' in registration) {
        await (registration as any).sync.register('background-sync');
      }
    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  }
  
  // ============================================================================
  // Event Handlers
  // ============================================================================
  
  private handleOnline = async (): Promise<void> => {
    this.syncStatus.isOnline = true;
    this.notifyListeners();
    
    // Trigger sync when coming back online
    this.sync();
  };
  
  private handleOffline = (): void => {
    this.syncStatus.isOnline = false;
    this.notifyListeners();
  };
  
  // ============================================================================
  // Status and Listeners
  // ============================================================================
  
  /**
   * Subscribe to sync status changes.
   */
  subscribe(listener: (status: SyncStatus) => void): () => void {
    this.listeners.add(listener);
    listener(this.syncStatus);
    
    return () => {
      this.listeners.delete(listener);
    };
  }
  
  /**
   * Get current sync status.
   */
  getStatus(): SyncStatus {
    return { ...this.syncStatus };
  }
  
  private async updatePendingCount(): Promise<void> {
    const queue = await this.dbGetAll(STORES.SYNC_QUEUE);
    this.syncStatus.pendingOperations = queue.length;
  }
  
  private notifyListeners(): void {
    const status = this.getStatus();
    this.listeners.forEach(listener => listener(status));
  }
  
  /**
   * Check if specific content is cached.
   */
  async isCached(type: 'reading_plan' | 'journey', id: number): Promise<boolean> {
    const store = type === 'reading_plan' ? STORES.READING_PLANS : STORES.JOURNEYS;
    const cached = await this.dbGet(store, id);
    return !!cached;
  }
  
  /**
   * Clear all cached data.
   */
  async clearCache(): Promise<void> {
    if (!this.db) return;
    
    const stores = Object.values(STORES);
    for (const storeName of stores) {
      if (storeName !== STORES.SYNC_QUEUE) {
        const store = await this.getStore(storeName, 'readwrite');
        await new Promise<void>((resolve, reject) => {
          const request = store.clear();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      }
    }
  }
}

// Export singleton instance
export const offlineService = new OfflineService();