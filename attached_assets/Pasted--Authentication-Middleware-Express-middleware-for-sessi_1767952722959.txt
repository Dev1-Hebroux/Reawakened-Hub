/**
 * Authentication Middleware
 * 
 * Express middleware for session-based authentication.
 * Handles cookie management, CSRF protection, and role-based access control.
 */

import { Request, Response, NextFunction } from 'express';
import { getUserBySession, validateSession } from '../services/authService';
import { logger } from '../lib/logger';
import crypto from 'crypto';

// ============================================================================
// Configuration
// ============================================================================

const SESSION_COOKIE_NAME = 'reawakened_session';
const CSRF_COOKIE_NAME = 'reawakened_csrf';
const CSRF_HEADER_NAME = 'x-csrf-token';

const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax' as const,
  path: '/',
  maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
};

// ============================================================================
// Types
// ============================================================================

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: number;
        email: string;
        firstName: string | null;
        lastName: string | null;
        role: 'user' | 'admin' | 'moderator';
        emailVerified: boolean;
      };
      sessionToken?: string;
    }
  }
}

// ============================================================================
// Session Cookie Management
// ============================================================================

/**
 * Set the session cookie.
 */
export function setSessionCookie(res: Response, token: string): void {
  res.cookie(SESSION_COOKIE_NAME, token, COOKIE_OPTIONS);
}

/**
 * Clear the session cookie.
 */
export function clearSessionCookie(res: Response): void {
  res.clearCookie(SESSION_COOKIE_NAME, { path: '/' });
}

/**
 * Get the session token from the request.
 */
export function getSessionToken(req: Request): string | null {
  return req.cookies?.[SESSION_COOKIE_NAME] || null;
}

// ============================================================================
// CSRF Protection
// ============================================================================

/**
 * Generate and set CSRF token.
 */
export function generateCsrfToken(res: Response): string {
  const token = crypto.randomBytes(32).toString('hex');
  
  res.cookie(CSRF_COOKIE_NAME, token, {
    ...COOKIE_OPTIONS,
    httpOnly: false, // Must be readable by JavaScript
  });
  
  return token;
}

/**
 * Validate CSRF token from request.
 */
function validateCsrfToken(req: Request): boolean {
  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];
  const headerToken = req.headers[CSRF_HEADER_NAME] as string;
  
  if (!cookieToken || !headerToken) {
    return false;
  }
  
  // Constant-time comparison to prevent timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(cookieToken),
      Buffer.from(headerToken)
    );
  } catch {
    return false;
  }
}

// ============================================================================
// Middleware Functions
// ============================================================================

/**
 * Load user from session if present.
 * Does not require authentication, just loads user if available.
 */
export async function loadUser(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const token = getSessionToken(req);
    
    if (token) {
      const user = await getUserBySession(token);
      
      if (user) {
        req.user = user;
        req.sessionToken = token;
      } else {
        // Invalid session, clear cookie
        clearSessionCookie(res);
      }
    }
    
    next();
  } catch (error) {
    logger.error({ error }, 'Error loading user session');
    next();
  }
}

/**
 * Require authentication.
 * Returns 401 if user is not logged in.
 */
export function requireAuth(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.user) {
    res.status(401).json({
      error: 'Authentication required',
      code: 'AUTH_REQUIRED',
    });
    return;
  }
  
  next();
}

/**
 * Require specific role(s).
 * Returns 403 if user doesn't have required role.
 */
export function requireRole(...roles: Array<'user' | 'admin' | 'moderator'>) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'AUTH_REQUIRED',
      });
      return;
    }
    
    if (!roles.includes(req.user.role)) {
      logger.warn({
        userId: req.user.id,
        requiredRoles: roles,
        userRole: req.user.role,
      }, 'Access denied - insufficient role');
      
      res.status(403).json({
        error: 'Access denied',
        code: 'INSUFFICIENT_PERMISSIONS',
      });
      return;
    }
    
    next();
  };
}

/**
 * Require admin role.
 */
export const requireAdmin = requireRole('admin');

/**
 * Require moderator or admin role.
 */
export const requireModerator = requireRole('admin', 'moderator');

/**
 * Require verified email.
 */
export function requireVerifiedEmail(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.user) {
    res.status(401).json({
      error: 'Authentication required',
      code: 'AUTH_REQUIRED',
    });
    return;
  }
  
  if (!req.user.emailVerified) {
    res.status(403).json({
      error: 'Email verification required',
      code: 'EMAIL_NOT_VERIFIED',
    });
    return;
  }
  
  next();
}

/**
 * CSRF protection middleware.
 * Validates CSRF token for state-changing requests.
 */
export function csrfProtection(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  // Skip CSRF for safe methods
  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];
  if (safeMethods.includes(req.method)) {
    next();
    return;
  }
  
  // Validate CSRF token
  if (!validateCsrfToken(req)) {
    logger.warn({
      method: req.method,
      path: req.path,
      ip: req.ip,
    }, 'CSRF validation failed');
    
    res.status(403).json({
      error: 'Invalid or missing CSRF token',
      code: 'CSRF_INVALID',
    });
    return;
  }
  
  next();
}

/**
 * Rate limiting state (in-memory, use Redis for production clusters).
 */
const rateLimitStore = new Map<string, { count: number; resetAt: number }>();

/**
 * Rate limiting middleware for authentication endpoints.
 */
export function authRateLimit(options: {
  windowMs?: number;
  maxAttempts?: number;
} = {}) {
  const windowMs = options.windowMs || 15 * 60 * 1000; // 15 minutes
  const maxAttempts = options.maxAttempts || 5;
  
  return (req: Request, res: Response, next: NextFunction): void => {
    const key = `auth:${req.ip}:${req.path}`;
    const now = Date.now();
    
    let record = rateLimitStore.get(key);
    
    if (!record || record.resetAt < now) {
      record = { count: 0, resetAt: now + windowMs };
      rateLimitStore.set(key, record);
    }
    
    record.count++;
    
    if (record.count > maxAttempts) {
      const retryAfter = Math.ceil((record.resetAt - now) / 1000);
      
      logger.warn({
        ip: req.ip,
        path: req.path,
        attempts: record.count,
      }, 'Rate limit exceeded');
      
      res.status(429)
        .set('Retry-After', String(retryAfter))
        .json({
          error: 'Too many attempts. Please try again later.',
          code: 'RATE_LIMITED',
          retryAfter,
        });
      return;
    }
    
    next();
  };
}

/**
 * Reset rate limit for an IP (call after successful login).
 */
export function resetRateLimit(ip: string, path: string): void {
  const key = `auth:${ip}:${path}`;
  rateLimitStore.delete(key);
}

/**
 * Clean up expired rate limit entries (run periodically).
 */
export function cleanupRateLimitStore(): void {
  const now = Date.now();
  
  for (const [key, record] of rateLimitStore.entries()) {
    if (record.resetAt < now) {
      rateLimitStore.delete(key);
    }
  }
}

// Clean up rate limit store every 5 minutes
setInterval(cleanupRateLimitStore, 5 * 60 * 1000);

// ============================================================================
// Utility Middleware
// ============================================================================

/**
 * Ensure CSRF token is set for all responses.
 */
export function ensureCsrfToken(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.cookies?.[CSRF_COOKIE_NAME]) {
    generateCsrfToken(res);
  }
  next();
}

/**
 * Log authentication events.
 */
export function logAuthEvent(event: string) {
  return (req: Request, res: Response, next: NextFunction): void => {
    res.on('finish', () => {
      logger.info({
        event,
        userId: req.user?.id,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        statusCode: res.statusCode,
      }, 'Auth event');
    });
    next();
  };
}