/**
 * Notification API Routes
 * 
 * Endpoints for managing user notifications.
 */

import { Router } from 'express';
import { isAuthenticated } from '../middleware/auth';
import { NotificationService } from '../services/notificationService';
import { schemas } from '@shared/schemas/validation';
import { logger } from '../lib/logger';

const router = Router();
const notificationService = new NotificationService();

/**
 * GET /api/notifications
 * Get user notifications with pagination.
 */
router.get('/', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const limit = Math.min(parseInt(req.query.limit as string) || 20, 50);
    const offset = parseInt(req.query.offset as string) || 0;
    const unreadOnly = req.query.unreadOnly === 'true';

    const result = await notificationService.getUserNotifications(userId, {
      limit,
      offset,
      unreadOnly,
    });

    res.json(result);
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/notifications/unread-count
 * Get unread notification count.
 */
router.get('/unread-count', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const count = await notificationService.getUnreadCount(userId);
    res.json({ count });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/notifications/:id/read
 * Mark a specific notification as read.
 */
router.post('/:id/read', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const notificationId = parseInt(req.params.id);

    if (isNaN(notificationId)) {
      return res.status(400).json({ error: 'Invalid notification ID' });
    }

    await notificationService.markAsRead(userId, notificationId);
    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/notifications/read-all
 * Mark all notifications as read.
 */
router.post('/read-all', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const count = await notificationService.markAllAsRead(userId);
    res.json({ success: true, count });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/notifications/push-subscription
 * Register a push notification subscription.
 */
router.post('/push-subscription', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const { endpoint, keys } = req.body;

    if (!endpoint || !keys?.p256dh || !keys?.auth) {
      return res.status(400).json({ error: 'Invalid push subscription' });
    }

    // Store the subscription (implementation in notificationStorage)
    await db.insert(pushSubscriptions).values({
      userId,
      endpoint,
      keys,
      createdAt: new Date(),
    }).onConflictDoUpdate({
      target: [pushSubscriptions.userId, pushSubscriptions.endpoint],
      set: { keys, createdAt: new Date() },
    });

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/notifications/push-subscription
 * Remove a push notification subscription.
 */
router.delete('/push-subscription', isAuthenticated, async (req, res, next) => {
  try {
    const userId = req.user!.id;
    const { endpoint } = req.body;

    if (!endpoint) {
      return res.status(400).json({ error: 'Endpoint required' });
    }

    await db.delete(pushSubscriptions)
      .where(and(
        eq(pushSubscriptions.userId, userId),
        eq(pushSubscriptions.endpoint, endpoint)
      ));

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

export const notificationRoutes = router;

// Placeholder imports that would come from actual project
declare const db: any;
declare const pushSubscriptions: any;
declare const and: any;
declare const eq: any;