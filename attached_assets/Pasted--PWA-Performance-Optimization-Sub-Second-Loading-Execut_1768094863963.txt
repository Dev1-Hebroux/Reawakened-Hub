# PWA Performance Optimization: Sub-Second Loading

## Executive Summary

Your app currently takes 10-20 minutes to load because the server blocks on content seeding. This guide provides a **permanent, production-grade solution** for achieving sub-second load times.

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        USER DEVICE                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   App Shell â”‚â”€â”€â”€â–¶â”‚   Service   â”‚â”€â”€â”€â–¶â”‚   IndexedDB Cache   â”‚  â”‚
â”‚  â”‚  (Instant)  â”‚    â”‚   Worker    â”‚    â”‚   (Offline Data)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                  â”‚                                     â”‚
â”‚         â–¼                  â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚  â”‚  React App  â”‚    â”‚  Background â”‚                             â”‚
â”‚  â”‚ (Hydrates)  â”‚    â”‚    Sync     â”‚                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SERVER                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Express   â”‚    â”‚  Background â”‚    â”‚     Database        â”‚  â”‚
â”‚  â”‚  (Instant)  â”‚    â”‚  Job Queue  â”‚    â”‚   (PostgreSQL)      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Part 1: Server-Side Fixes (Critical)

### Problem: Blocking Startup

```typescript
// âŒ CURRENT - Blocks ALL requests for 10-20 minutes
await autoSeedDominionContent();
```

### Solution: Non-Blocking Background Jobs

```typescript
// âœ… FIXED - Server responds immediately
// server/index.ts

httpServer.listen({ port, host: "0.0.0.0", reusePort: true }, () => {
  log(`serving on port ${port}`);
  
  // CRITICAL: All heavy operations run AFTER server is ready
  // Use setImmediate to yield to event loop first
  setImmediate(async () => {
    try {
      // Run seeding in background - don't await in main flow
      autoSeedDominionContent().catch(err => {
        console.error('[Background] Seeding error:', err);
      });
      
      // Start schedulers after a delay to not compete with initial requests
      setTimeout(() => {
        startNightlyContentSync();
        if (process.env.OPENAI_API_KEY) {
          scheduleAudioPregeneration();
        }
        initializeNotificationScheduler();
        jobScheduler.start();
        log('Background services initialized');
      }, 5000); // 5 second delay
      
    } catch (error) {
      console.error('[Background] Initialization error:', error);
    }
  });
});
```

### Enhanced Auto-Seed with Batching

```typescript
// server/auto-seed.ts - Optimized version

export async function autoSeedDominionContent(): Promise<void> {
  try {
    console.log('[Auto-Seed] Starting background content sync...');
    
    const content = getDominionSeedContent();
    
    // OPTIMIZATION 1: Batch database operations
    const BATCH_SIZE = 20;
    
    // Process sparks in batches with delays to not block event loop
    for (let i = 0; i < content.sparks.length; i += BATCH_SIZE) {
      const batch = content.sparks.slice(i, i + BATCH_SIZE);
      
      // Process batch in parallel
      await Promise.all(batch.map(spark => storage.upsertSpark(spark)));
      
      // Yield to event loop between batches
      await new Promise(resolve => setImmediate(resolve));
    }
    
    // Same for reflection cards
    for (let i = 0; i < content.reflectionCards.length; i += BATCH_SIZE) {
      const batch = content.reflectionCards.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(card => storage.upsertReflectionCard(card)));
      await new Promise(resolve => setImmediate(resolve));
    }
    
    console.log('[Auto-Seed] Background sync complete');
  } catch (error) {
    console.error('[Auto-Seed] Error:', error);
    // Don't throw - this is background work
  }
}
```

---

## Part 2: Client-Side PWA Optimizations

### 2.1 App Shell Architecture

Create an instant-loading shell that displays while data loads:

```typescript
// client/src/components/AppShell.tsx

import { Suspense, lazy } from 'react';

// Skeleton that renders instantly
function AppSkeleton() {
  return (
    <div className="min-h-screen bg-background">
      {/* Header skeleton */}
      <header className="h-16 border-b bg-card animate-pulse" />
      
      {/* Content skeleton */}
      <main className="container mx-auto p-4">
        <div className="space-y-4">
          <div className="h-48 bg-muted rounded-lg animate-pulse" />
          <div className="h-24 bg-muted rounded-lg animate-pulse" />
          <div className="h-24 bg-muted rounded-lg animate-pulse" />
        </div>
      </main>
      
      {/* Bottom nav skeleton */}
      <nav className="fixed bottom-0 h-16 w-full border-t bg-card" />
    </div>
  );
}

// Lazy load heavy components
const Dashboard = lazy(() => import('./pages/Dashboard'));
const SparkDetail = lazy(() => import('./pages/SparkDetail'));

export function AppShell({ children }: { children: React.ReactNode }) {
  return (
    <Suspense fallback={<AppSkeleton />}>
      {children}
    </Suspense>
  );
}
```

### 2.2 Optimistic UI with Stale-While-Revalidate

```typescript
// client/src/hooks/useDashboard.ts - Optimized

import { useQuery, useQueryClient } from '@tanstack/react-query';

export function useDashboard(options: UseDashboardOptions = {}) {
  const queryClient = useQueryClient();
  
  return useQuery({
    queryKey: ['/api/sparks/dashboard', effectiveAudience],
    queryFn: async () => {
      const response = await fetch(`/api/sparks/dashboard${audienceParam}`);
      if (!response.ok) throw new Error('Failed to load');
      return response.json();
    },
    
    // CRITICAL: Stale-while-revalidate pattern
    staleTime: 5 * 60 * 1000,        // Data fresh for 5 minutes
    gcTime: 24 * 60 * 60 * 1000,     // Keep in cache for 24 hours
    
    // Show cached data immediately, refetch in background
    placeholderData: () => queryClient.getQueryData(['/api/sparks/dashboard']),
    
    // Retry with exponential backoff
    retry: 3,
    retryDelay: (attempt) => Math.min(1000 * 2 ** attempt, 10000),
    
    // Refetch on window focus for fresh data
    refetchOnWindowFocus: true,
    refetchOnReconnect: true,
  });
}
```

### 2.3 Service Worker with Aggressive Caching

```typescript
// public/sw.js - Production service worker

const CACHE_NAME = 'spark-v1';
const STATIC_CACHE = 'static-v1';
const API_CACHE = 'api-v1';

// Static assets to precache
const PRECACHE_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  // Add your JS/CSS bundles
];

// Install: Precache static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      return cache.addAll(PRECACHE_ASSETS);
    })
  );
  self.skipWaiting();
});

// Activate: Clean old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys
          .filter((key) => key !== CACHE_NAME && key !== STATIC_CACHE && key !== API_CACHE)
          .map((key) => caches.delete(key))
      );
    })
  );
  self.clients.claim();
});

// Fetch: Network-first for API, Cache-first for static
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // API requests: Network first, fallback to cache
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstStrategy(request));
    return;
  }
  
  // Static assets: Cache first, fallback to network
  if (isStaticAsset(url.pathname)) {
    event.respondWith(cacheFirstStrategy(request));
    return;
  }
  
  // HTML: Stale-while-revalidate
  if (request.headers.get('accept')?.includes('text/html')) {
    event.respondWith(staleWhileRevalidate(request));
    return;
  }
  
  // Default: Network
  event.respondWith(fetch(request));
});

async function networkFirstStrategy(request) {
  try {
    const response = await fetch(request);
    
    // Cache successful GET responses
    if (response.ok && request.method === 'GET') {
      const cache = await caches.open(API_CACHE);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    // Offline: Return cached response
    const cached = await caches.match(request);
    if (cached) return cached;
    
    // Return offline fallback for dashboard
    if (request.url.includes('/api/sparks/dashboard')) {
      return new Response(JSON.stringify({
        sparks: [],
        todaySpark: null,
        featured: [],
        reflection: null,
        sessions: [],
        meta: { offline: true }
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    throw error;
  }
}

async function cacheFirstStrategy(request) {
  const cached = await caches.match(request);
  if (cached) return cached;
  
  const response = await fetch(request);
  if (response.ok) {
    const cache = await caches.open(STATIC_CACHE);
    cache.put(request, response.clone());
  }
  
  return response;
}

async function staleWhileRevalidate(request) {
  const cached = await caches.match(request);
  
  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      const cache = caches.open(CACHE_NAME);
      cache.then((c) => c.put(request, response.clone()));
    }
    return response;
  });
  
  return cached || fetchPromise;
}

function isStaticAsset(pathname) {
  return /\.(js|css|png|jpg|jpeg|gif|svg|woff2?|ttf|eot|ico)$/i.test(pathname);
}
```

### 2.4 Lazy Audio Loading (Save Mobile Data)

```typescript
// client/src/hooks/useAudioPlayer.ts - Optimized

export function useAudioPlayer(options: UseAudioPlayerOptions = {}): UseAudioPlayerReturn {
  const { 
    initialTrack = DEFAULT_BACKGROUND_TRACKS[0],
    backgroundVolume = 0.3,
  } = options;
  
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  
  // OPTIMIZATION: Don't create Audio element until user interaction
  const initializeAudio = useCallback(() => {
    if (isInitialized || audioRef.current) return;
    
    const audio = new Audio();
    audio.preload = 'none'; // Don't preload until needed
    audio.src = initialTrack.url;
    audioRef.current = audio;
    setIsInitialized(true);
  }, [initialTrack.url, isInitialized]);
  
  const toggleBackgroundPlayback = useCallback(async () => {
    // Initialize on first interaction
    initializeAudio();
    
    if (!audioRef.current) return;
    
    if (isBackgroundPlaying) {
      audioRef.current.pause();
      setIsBackgroundPlaying(false);
    } else {
      // Only load when actually playing
      if (audioRef.current.readyState < 2) {
        audioRef.current.load();
      }
      const success = await safePlay(audioRef.current);
      setIsBackgroundPlaying(success);
    }
  }, [isBackgroundPlaying, safePlay, initializeAudio]);
  
  // ... rest of implementation
}
```

---

## Part 3: Build & Deployment Optimizations

### 3.1 Vite Configuration for PWA

```typescript
// vite.config.ts

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'robots.txt', 'apple-touch-icon.png'],
      manifest: {
        name: 'Your App Name',
        short_name: 'App',
        theme_color: '#000000',
        background_color: '#000000',
        display: 'standalone',
        start_url: '/',
        icons: [
          { src: '/icon-192.png', sizes: '192x192', type: 'image/png' },
          { src: '/icon-512.png', sizes: '512x512', type: 'image/png' },
        ],
      },
      workbox: {
        // Precache all static assets
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        
        // Runtime caching for API
        runtimeCaching: [
          {
            urlPattern: /^\/api\/sparks\/dashboard/,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'dashboard-cache',
              expiration: { maxEntries: 10, maxAgeSeconds: 60 * 60 }, // 1 hour
            },
          },
          {
            urlPattern: /^\/api\//,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: { maxEntries: 50, maxAgeSeconds: 60 * 5 }, // 5 minutes
            },
          },
          {
            urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'image-cache',
              expiration: { maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 30 }, // 30 days
            },
          },
        ],
      },
    }),
  ],
  
  build: {
    // Code splitting for smaller initial bundle
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor-react': ['react', 'react-dom'],
          'vendor-query': ['@tanstack/react-query'],
          'vendor-ui': ['@radix-ui/react-dialog', '@radix-ui/react-dropdown-menu'],
        },
      },
    },
    
    // Target modern browsers for smaller bundles
    target: 'es2020',
    
    // Enable minification
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
  },
});
```

### 3.2 Critical CSS Inlining

```html
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Preconnect to critical origins -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="dns-prefetch" href="https://api.yourdomain.com" />
  
  <!-- Critical CSS inlined for instant render -->
  <style>
    /* Minimal CSS for app shell - renders before JS loads */
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:system-ui,-apple-system,sans-serif;background:#0a0a0a;color:#fff}
    .app-shell{min-height:100vh;display:flex;flex-direction:column}
    .skeleton{background:linear-gradient(90deg,#1a1a1a 25%,#2a2a2a 50%,#1a1a1a 75%);
      background-size:200% 100%;animation:shimmer 1.5s infinite}
    @keyframes shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}
  </style>
  
  <!-- Preload critical resources -->
  <link rel="preload" href="/fonts/inter-var.woff2" as="font" type="font/woff2" crossorigin />
  
  <!-- PWA manifest -->
  <link rel="manifest" href="/manifest.json" />
  <meta name="theme-color" content="#000000" />
</head>
<body>
  <!-- App shell renders immediately -->
  <div id="root">
    <div class="app-shell">
      <header style="height:64px;border-bottom:1px solid #222"></header>
      <main style="flex:1;padding:16px">
        <div class="skeleton" style="height:200px;border-radius:12px;margin-bottom:16px"></div>
        <div class="skeleton" style="height:100px;border-radius:12px;margin-bottom:16px"></div>
        <div class="skeleton" style="height:100px;border-radius:12px"></div>
      </main>
    </div>
  </div>
  
  <!-- Defer non-critical JS -->
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

---

## Part 4: Performance Monitoring

### 4.1 Web Vitals Tracking

```typescript
// client/src/lib/vitals.ts

import { onCLS, onFID, onFCP, onLCP, onTTFB } from 'web-vitals';

export function reportWebVitals() {
  onCLS(metric => sendToAnalytics('CLS', metric));
  onFID(metric => sendToAnalytics('FID', metric));
  onFCP(metric => sendToAnalytics('FCP', metric));
  onLCP(metric => sendToAnalytics('LCP', metric));
  onTTFB(metric => sendToAnalytics('TTFB', metric));
}

function sendToAnalytics(name: string, metric: any) {
  // Log in development
  if (import.meta.env.DEV) {
    console.log(`[Vitals] ${name}:`, metric.value.toFixed(0), 'ms');
    return;
  }
  
  // Send to your analytics in production
  fetch('/api/analytics/vitals', {
    method: 'POST',
    body: JSON.stringify({ name, value: metric.value, id: metric.id }),
    headers: { 'Content-Type': 'application/json' },
    keepalive: true,
  });
}
```

---

## Implementation Priority

| Priority | Task | Impact | Effort |
|----------|------|--------|--------|
| ðŸ”´ P0 | Remove `await autoSeedDominionContent()` | Fixes 20min load | 5 min |
| ðŸ”´ P0 | Add setImmediate wrapper for background jobs | Immediate response | 10 min |
| ðŸŸ  P1 | Implement Service Worker caching | Offline + fast reload | 2 hours |
| ðŸŸ  P1 | Add App Shell with Suspense | Instant perceived load | 1 hour |
| ðŸŸ¡ P2 | Lazy load audio components | Save mobile data | 30 min |
| ðŸŸ¡ P2 | Configure Vite PWA plugin | Automated caching | 1 hour |
| ðŸŸ¢ P3 | Add Web Vitals monitoring | Track performance | 30 min |
| ðŸŸ¢ P3 | Optimize bundle splitting | Smaller initial load | 1 hour |

---

## Expected Results

After implementing these changes:

| Metric | Before | After | Target |
|--------|--------|-------|--------|
| Time to First Byte (TTFB) | 10-20 min | < 200ms | âœ… |
| First Contentful Paint (FCP) | 10-20 min | < 500ms | âœ… |
| Largest Contentful Paint (LCP) | 10-20 min | < 1.5s | âœ… |
| Time to Interactive (TTI) | 10-20 min | < 2s | âœ… |
| Repeat Visit Load | 10-20 min | < 100ms | âœ… (from cache) |
| Offline Support | âŒ None | âœ… Full | âœ… |

---

## Quick Fix (Do This First)

If you need an immediate fix, change just these lines in `server/index.ts`:

```typescript
// BEFORE (line ~130)
await autoSeedDominionContent();

// AFTER
autoSeedDominionContent().catch(err => console.error('[Seed Error]', err));
```

This single change will make your server respond immediately instead of waiting 20 minutes.